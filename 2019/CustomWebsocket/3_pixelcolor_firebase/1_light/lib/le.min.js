/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.0
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

! function (t, n) {
    if ("object" == typeof exports && "object" == typeof module) module.exports = n();
    else if ("function" == typeof define && define.amd) define(n);
    else {
        var r = n();
        for (var a in r)("object" == typeof exports ? exports : t)[a] = r[a]
    }
}(this, function () {
    return function (t) {
        function n(a) {
            if (r[a]) return r[a].exports;
            var e = r[a] = {
                exports: {},
                id: a,
                loaded: !1
            };
            return t[a].call(e.exports, e, e.exports, n), e.loaded = !0, e.exports
        }
        var r = {};
        return n.m = t, n.c = r, n.p = "", n(0)
    }([function (t, n, r) {
        n.glMatrix = r(1), n.mat2 = r(2), n.mat2d = r(3), n.mat3 = r(4), n.mat4 = r(5), n.quat = r(6), n.vec2 = r(9), n.vec3 = r(7), n.vec4 = r(8)
    }, function (t, n) {
        var r = {};
        r.EPSILON = 1e-6, r.ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array, r.RANDOM = Math.random, r.setMatrixArrayType = function (t) {
            GLMAT_ARRAY_TYPE = t
        };
        var a = Math.PI / 180;
        r.toRadian = function (t) {
            return t * a
        }, t.exports = r
    }, function (t, n, r) {
        var a = r(1),
            e = {};
        e.create = function () {
            var t = new a.ARRAY_TYPE(4);
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t
        }, e.clone = function (t) {
            var n = new a.ARRAY_TYPE(4);
            return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n
        }, e.copy = function (t, n) {
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t
        }, e.identity = function (t) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t
        }, e.transpose = function (t, n) {
            if (t === n) {
                var r = n[1];
                t[1] = n[2], t[2] = r
            } else t[0] = n[0], t[1] = n[2], t[2] = n[1], t[3] = n[3];
            return t
        }, e.invert = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = n[3],
                o = r * u - e * a;
            return o ? (o = 1 / o, t[0] = u * o, t[1] = -a * o, t[2] = -e * o, t[3] = r * o, t) : null
        }, e.adjoint = function (t, n) {
            var r = n[0];
            return t[0] = n[3], t[1] = -n[1], t[2] = -n[2], t[3] = r, t
        }, e.determinant = function (t) {
            return t[0] * t[3] - t[2] * t[1]
        }, e.multiply = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = r[0],
                c = r[1],
                f = r[2],
                s = r[3];
            return t[0] = a * i + u * c, t[1] = e * i + o * c, t[2] = a * f + u * s, t[3] = e * f + o * s, t
        }, e.mul = e.multiply, e.rotate = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = Math.sin(r),
                c = Math.cos(r);
            return t[0] = a * c + u * i, t[1] = e * c + o * i, t[2] = a * -i + u * c, t[3] = e * -i + o * c, t
        }, e.scale = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = r[0],
                c = r[1];
            return t[0] = a * i, t[1] = e * i, t[2] = u * c, t[3] = o * c, t
        }, e.fromRotation = function (t, n) {
            var r = Math.sin(n),
                a = Math.cos(n);
            return t[0] = a, t[1] = r, t[2] = -r, t[3] = a, t
        }, e.fromScaling = function (t, n) {
            return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = n[1], t
        }, e.str = function (t) {
            return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
        }, e.frob = function (t) {
            return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2))
        }, e.LDU = function (t, n, r, a) {
            return t[2] = a[2] / a[0], r[0] = a[0], r[1] = a[1], r[3] = a[3] - t[2] * r[1], [t, n, r]
        }, t.exports = e
    }, function (t, n, r) {
        var a = r(1),
            e = {};
        e.create = function () {
            var t = new a.ARRAY_TYPE(6);
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
        }, e.clone = function (t) {
            var n = new a.ARRAY_TYPE(6);
            return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n
        }, e.copy = function (t, n) {
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t
        }, e.identity = function (t) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
        }, e.invert = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = n[3],
                o = n[4],
                i = n[5],
                c = r * u - a * e;
            return c ? (c = 1 / c, t[0] = u * c, t[1] = -a * c, t[2] = -e * c, t[3] = r * c, t[4] = (e * i - u * o) * c, t[5] = (a * o - r * i) * c, t) : null
        }, e.determinant = function (t) {
            return t[0] * t[3] - t[1] * t[2]
        }, e.multiply = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = n[4],
                c = n[5],
                f = r[0],
                s = r[1],
                h = r[2],
                M = r[3],
                l = r[4],
                v = r[5];
            return t[0] = a * f + u * s, t[1] = e * f + o * s, t[2] = a * h + u * M, t[3] = e * h + o * M, t[4] = a * l + u * v + i, t[5] = e * l + o * v + c, t
        }, e.mul = e.multiply, e.rotate = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = n[4],
                c = n[5],
                f = Math.sin(r),
                s = Math.cos(r);
            return t[0] = a * s + u * f, t[1] = e * s + o * f, t[2] = a * -f + u * s, t[3] = e * -f + o * s, t[4] = i, t[5] = c, t
        }, e.scale = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = n[4],
                c = n[5],
                f = r[0],
                s = r[1];
            return t[0] = a * f, t[1] = e * f, t[2] = u * s, t[3] = o * s, t[4] = i, t[5] = c, t
        }, e.translate = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = n[4],
                c = n[5],
                f = r[0],
                s = r[1];
            return t[0] = a, t[1] = e, t[2] = u, t[3] = o, t[4] = a * f + u * s + i, t[5] = e * f + o * s + c, t
        }, e.fromRotation = function (t, n) {
            var r = Math.sin(n),
                a = Math.cos(n);
            return t[0] = a, t[1] = r, t[2] = -r, t[3] = a, t[4] = 0, t[5] = 0, t
        }, e.fromScaling = function (t, n) {
            return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = n[1], t[4] = 0, t[5] = 0, t
        }, e.fromTranslation = function (t, n) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = n[0], t[5] = n[1], t
        }, e.str = function (t) {
            return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")"
        }, e.frob = function (t) {
            return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + 1)
        }, t.exports = e
    }, function (t, n, r) {
        var a = r(1),
            e = {};
        e.create = function () {
            var t = new a.ARRAY_TYPE(9);
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
        }, e.fromMat4 = function (t, n) {
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[4], t[4] = n[5], t[5] = n[6], t[6] = n[8], t[7] = n[9], t[8] = n[10], t
        }, e.clone = function (t) {
            var n = new a.ARRAY_TYPE(9);
            return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n
        }, e.copy = function (t, n) {
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t
        }, e.identity = function (t) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
        }, e.transpose = function (t, n) {
            if (t === n) {
                var r = n[1],
                    a = n[2],
                    e = n[5];
                t[1] = n[3], t[2] = n[6], t[3] = r, t[5] = n[7], t[6] = a, t[7] = e
            } else t[0] = n[0], t[1] = n[3], t[2] = n[6], t[3] = n[1], t[4] = n[4], t[5] = n[7], t[6] = n[2], t[7] = n[5], t[8] = n[8];
            return t
        }, e.invert = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = n[3],
                o = n[4],
                i = n[5],
                c = n[6],
                f = n[7],
                s = n[8],
                h = s * o - i * f,
                M = -s * u + i * c,
                l = f * u - o * c,
                v = r * h + a * M + e * l;
            return v ? (v = 1 / v, t[0] = h * v, t[1] = (-s * a + e * f) * v, t[2] = (i * a - e * o) * v, t[3] = M * v, t[4] = (s * r - e * c) * v, t[5] = (-i * r + e * u) * v, t[6] = l * v, t[7] = (-f * r + a * c) * v, t[8] = (o * r - a * u) * v, t) : null
        }, e.adjoint = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = n[3],
                o = n[4],
                i = n[5],
                c = n[6],
                f = n[7],
                s = n[8];
            return t[0] = o * s - i * f, t[1] = e * f - a * s, t[2] = a * i - e * o, t[3] = i * c - u * s, t[4] = r * s - e * c, t[5] = e * u - r * i, t[6] = u * f - o * c, t[7] = a * c - r * f, t[8] = r * o - a * u, t
        }, e.determinant = function (t) {
            var n = t[0],
                r = t[1],
                a = t[2],
                e = t[3],
                u = t[4],
                o = t[5],
                i = t[6],
                c = t[7],
                f = t[8];
            return n * (f * u - o * c) + r * (-f * e + o * i) + a * (c * e - u * i)
        }, e.multiply = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = n[4],
                c = n[5],
                f = n[6],
                s = n[7],
                h = n[8],
                M = r[0],
                l = r[1],
                v = r[2],
                m = r[3],
                p = r[4],
                d = r[5],
                A = r[6],
                R = r[7],
                w = r[8];
            return t[0] = M * a + l * o + v * f, t[1] = M * e + l * i + v * s, t[2] = M * u + l * c + v * h, t[3] = m * a + p * o + d * f, t[4] = m * e + p * i + d * s, t[5] = m * u + p * c + d * h, t[6] = A * a + R * o + w * f, t[7] = A * e + R * i + w * s, t[8] = A * u + R * c + w * h, t
        }, e.mul = e.multiply, e.translate = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = n[4],
                c = n[5],
                f = n[6],
                s = n[7],
                h = n[8],
                M = r[0],
                l = r[1];
            return t[0] = a, t[1] = e, t[2] = u, t[3] = o, t[4] = i, t[5] = c, t[6] = M * a + l * o + f, t[7] = M * e + l * i + s, t[8] = M * u + l * c + h, t
        }, e.rotate = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = n[4],
                c = n[5],
                f = n[6],
                s = n[7],
                h = n[8],
                M = Math.sin(r),
                l = Math.cos(r);
            return t[0] = l * a + M * o, t[1] = l * e + M * i, t[2] = l * u + M * c, t[3] = l * o - M * a, t[4] = l * i - M * e, t[5] = l * c - M * u, t[6] = f, t[7] = s, t[8] = h, t
        }, e.scale = function (t, n, r) {
            var a = r[0],
                e = r[1];
            return t[0] = a * n[0], t[1] = a * n[1], t[2] = a * n[2], t[3] = e * n[3], t[4] = e * n[4], t[5] = e * n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t
        }, e.fromTranslation = function (t, n) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = n[0], t[7] = n[1], t[8] = 1, t
        }, e.fromRotation = function (t, n) {
            var r = Math.sin(n),
                a = Math.cos(n);
            return t[0] = a, t[1] = r, t[2] = 0, t[3] = -r, t[4] = a, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
        }, e.fromScaling = function (t, n) {
            return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = n[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
        }, e.fromMat2d = function (t, n) {
            return t[0] = n[0], t[1] = n[1], t[2] = 0, t[3] = n[2], t[4] = n[3], t[5] = 0, t[6] = n[4], t[7] = n[5], t[8] = 1, t
        }, e.fromQuat = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = n[3],
                o = r + r,
                i = a + a,
                c = e + e,
                f = r * o,
                s = a * o,
                h = a * i,
                M = e * o,
                l = e * i,
                v = e * c,
                m = u * o,
                p = u * i,
                d = u * c;
            return t[0] = 1 - h - v, t[3] = s - d, t[6] = M + p, t[1] = s + d, t[4] = 1 - f - v, t[7] = l - m, t[2] = M - p, t[5] = l + m, t[8] = 1 - f - h, t
        }, e.normalFromMat4 = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = n[3],
                o = n[4],
                i = n[5],
                c = n[6],
                f = n[7],
                s = n[8],
                h = n[9],
                M = n[10],
                l = n[11],
                v = n[12],
                m = n[13],
                p = n[14],
                d = n[15],
                A = r * i - a * o,
                R = r * c - e * o,
                w = r * f - u * o,
                q = a * c - e * i,
                Y = a * f - u * i,
                g = e * f - u * c,
                y = s * m - h * v,
                x = s * p - M * v,
                P = s * d - l * v,
                E = h * p - M * m,
                T = h * d - l * m,
                b = M * d - l * p,
                D = A * b - R * T + w * E + q * P - Y * x + g * y;
            return D ? (D = 1 / D, t[0] = (i * b - c * T + f * E) * D, t[1] = (c * P - o * b - f * x) * D, t[2] = (o * T - i * P + f * y) * D, t[3] = (e * T - a * b - u * E) * D, t[4] = (r * b - e * P + u * x) * D, t[5] = (a * P - r * T - u * y) * D, t[6] = (m * g - p * Y + d * q) * D, t[7] = (p * w - v * g - d * R) * D, t[8] = (v * Y - m * w + d * A) * D, t) : null
        }, e.str = function (t) {
            return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")"
        }, e.frob = function (t) {
            return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2))
        }, t.exports = e
    }, function (t, n, r) {
        var a = r(1),
            e = {};
        e.create = function () {
            var t = new a.ARRAY_TYPE(16);
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, e.clone = function (t) {
            var n = new a.ARRAY_TYPE(16);
            return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
        }, e.copy = function (t, n) {
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t
        }, e.identity = function (t) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, e.transpose = function (t, n) {
            if (t === n) {
                var r = n[1],
                    a = n[2],
                    e = n[3],
                    u = n[6],
                    o = n[7],
                    i = n[11];
                t[1] = n[4], t[2] = n[8], t[3] = n[12], t[4] = r, t[6] = n[9], t[7] = n[13], t[8] = a, t[9] = u, t[11] = n[14], t[12] = e, t[13] = o, t[14] = i
            } else t[0] = n[0], t[1] = n[4], t[2] = n[8], t[3] = n[12], t[4] = n[1], t[5] = n[5], t[6] = n[9], t[7] = n[13], t[8] = n[2], t[9] = n[6], t[10] = n[10], t[11] = n[14], t[12] = n[3], t[13] = n[7], t[14] = n[11], t[15] = n[15];
            return t
        }, e.invert = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = n[3],
                o = n[4],
                i = n[5],
                c = n[6],
                f = n[7],
                s = n[8],
                h = n[9],
                M = n[10],
                l = n[11],
                v = n[12],
                m = n[13],
                p = n[14],
                d = n[15],
                A = r * i - a * o,
                R = r * c - e * o,
                w = r * f - u * o,
                q = a * c - e * i,
                Y = a * f - u * i,
                g = e * f - u * c,
                y = s * m - h * v,
                x = s * p - M * v,
                P = s * d - l * v,
                E = h * p - M * m,
                T = h * d - l * m,
                b = M * d - l * p,
                D = A * b - R * T + w * E + q * P - Y * x + g * y;
            return D ? (D = 1 / D, t[0] = (i * b - c * T + f * E) * D, t[1] = (e * T - a * b - u * E) * D, t[2] = (m * g - p * Y + d * q) * D, t[3] = (M * Y - h * g - l * q) * D, t[4] = (c * P - o * b - f * x) * D, t[5] = (r * b - e * P + u * x) * D, t[6] = (p * w - v * g - d * R) * D, t[7] = (s * g - M * w + l * R) * D, t[8] = (o * T - i * P + f * y) * D, t[9] = (a * P - r * T - u * y) * D, t[10] = (v * Y - m * w + d * A) * D, t[11] = (h * w - s * Y - l * A) * D, t[12] = (i * x - o * E - c * y) * D, t[13] = (r * E - a * x + e * y) * D, t[14] = (m * R - v * q - p * A) * D, t[15] = (s * q - h * R + M * A) * D, t) : null
        }, e.adjoint = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = n[3],
                o = n[4],
                i = n[5],
                c = n[6],
                f = n[7],
                s = n[8],
                h = n[9],
                M = n[10],
                l = n[11],
                v = n[12],
                m = n[13],
                p = n[14],
                d = n[15];
            return t[0] = i * (M * d - l * p) - h * (c * d - f * p) + m * (c * l - f * M), t[1] = -(a * (M * d - l * p) - h * (e * d - u * p) + m * (e * l - u * M)), t[2] = a * (c * d - f * p) - i * (e * d - u * p) + m * (e * f - u * c), t[3] = -(a * (c * l - f * M) - i * (e * l - u * M) + h * (e * f - u * c)), t[4] = -(o * (M * d - l * p) - s * (c * d - f * p) + v * (c * l - f * M)), t[5] = r * (M * d - l * p) - s * (e * d - u * p) + v * (e * l - u * M), t[6] = -(r * (c * d - f * p) - o * (e * d - u * p) + v * (e * f - u * c)), t[7] = r * (c * l - f * M) - o * (e * l - u * M) + s * (e * f - u * c), t[8] = o * (h * d - l * m) - s * (i * d - f * m) + v * (i * l - f * h), t[9] = -(r * (h * d - l * m) - s * (a * d - u * m) + v * (a * l - u * h)), t[10] = r * (i * d - f * m) - o * (a * d - u * m) + v * (a * f - u * i), t[11] = -(r * (i * l - f * h) - o * (a * l - u * h) + s * (a * f - u * i)), t[12] = -(o * (h * p - M * m) - s * (i * p - c * m) + v * (i * M - c * h)), t[13] = r * (h * p - M * m) - s * (a * p - e * m) + v * (a * M - e * h), t[14] = -(r * (i * p - c * m) - o * (a * p - e * m) + v * (a * c - e * i)), t[15] = r * (i * M - c * h) - o * (a * M - e * h) + s * (a * c - e * i), t
        }, e.determinant = function (t) {
            var n = t[0],
                r = t[1],
                a = t[2],
                e = t[3],
                u = t[4],
                o = t[5],
                i = t[6],
                c = t[7],
                f = t[8],
                s = t[9],
                h = t[10],
                M = t[11],
                l = t[12],
                v = t[13],
                m = t[14],
                p = t[15],
                d = n * o - r * u,
                A = n * i - a * u,
                R = n * c - e * u,
                w = r * i - a * o,
                q = r * c - e * o,
                Y = a * c - e * i,
                g = f * v - s * l,
                y = f * m - h * l,
                x = f * p - M * l,
                P = s * m - h * v,
                E = s * p - M * v,
                T = h * p - M * m;
            return d * T - A * E + R * P + w * x - q * y + Y * g
        }, e.multiply = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = n[4],
                c = n[5],
                f = n[6],
                s = n[7],
                h = n[8],
                M = n[9],
                l = n[10],
                v = n[11],
                m = n[12],
                p = n[13],
                d = n[14],
                A = n[15],
                R = r[0],
                w = r[1],
                q = r[2],
                Y = r[3];
            return t[0] = R * a + w * i + q * h + Y * m, t[1] = R * e + w * c + q * M + Y * p, t[2] = R * u + w * f + q * l + Y * d, t[3] = R * o + w * s + q * v + Y * A, R = r[4], w = r[5], q = r[6], Y = r[7], t[4] = R * a + w * i + q * h + Y * m, t[5] = R * e + w * c + q * M + Y * p, t[6] = R * u + w * f + q * l + Y * d, t[7] = R * o + w * s + q * v + Y * A, R = r[8], w = r[9], q = r[10], Y = r[11], t[8] = R * a + w * i + q * h + Y * m, t[9] = R * e + w * c + q * M + Y * p, t[10] = R * u + w * f + q * l + Y * d, t[11] = R * o + w * s + q * v + Y * A, R = r[12], w = r[13], q = r[14], Y = r[15], t[12] = R * a + w * i + q * h + Y * m, t[13] = R * e + w * c + q * M + Y * p, t[14] = R * u + w * f + q * l + Y * d, t[15] = R * o + w * s + q * v + Y * A, t
        }, e.mul = e.multiply, e.translate = function (t, n, r) {
            var a, e, u, o, i, c, f, s, h, M, l, v, m = r[0],
                p = r[1],
                d = r[2];
            return n === t ? (t[12] = n[0] * m + n[4] * p + n[8] * d + n[12], t[13] = n[1] * m + n[5] * p + n[9] * d + n[13], t[14] = n[2] * m + n[6] * p + n[10] * d + n[14], t[15] = n[3] * m + n[7] * p + n[11] * d + n[15]) : (a = n[0], e = n[1], u = n[2], o = n[3], i = n[4], c = n[5], f = n[6], s = n[7], h = n[8], M = n[9], l = n[10], v = n[11], t[0] = a, t[1] = e, t[2] = u, t[3] = o, t[4] = i, t[5] = c, t[6] = f, t[7] = s, t[8] = h, t[9] = M, t[10] = l, t[11] = v, t[12] = a * m + i * p + h * d + n[12], t[13] = e * m + c * p + M * d + n[13], t[14] = u * m + f * p + l * d + n[14], t[15] = o * m + s * p + v * d + n[15]), t
        }, e.scale = function (t, n, r) {
            var a = r[0],
                e = r[1],
                u = r[2];
            return t[0] = n[0] * a, t[1] = n[1] * a, t[2] = n[2] * a, t[3] = n[3] * a, t[4] = n[4] * e, t[5] = n[5] * e, t[6] = n[6] * e, t[7] = n[7] * e, t[8] = n[8] * u, t[9] = n[9] * u, t[10] = n[10] * u, t[11] = n[11] * u, t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t
        }, e.rotate = function (t, n, r, e) {
            var u, o, i, c, f, s, h, M, l, v, m, p, d, A, R, w, q, Y, g, y, x, P, E, T, b = e[0],
                D = e[1],
                L = e[2],
                _ = Math.sqrt(b * b + D * D + L * L);
            return Math.abs(_) < a.EPSILON ? null : (_ = 1 / _, b *= _, D *= _, L *= _, u = Math.sin(r), o = Math.cos(r), i = 1 - o, c = n[0], f = n[1], s = n[2], h = n[3], M = n[4], l = n[5], v = n[6], m = n[7], p = n[8], d = n[9], A = n[10], R = n[11], w = b * b * i + o, q = D * b * i + L * u, Y = L * b * i - D * u, g = b * D * i - L * u, y = D * D * i + o, x = L * D * i + b * u, P = b * L * i + D * u, E = D * L * i - b * u, T = L * L * i + o, t[0] = c * w + M * q + p * Y, t[1] = f * w + l * q + d * Y, t[2] = s * w + v * q + A * Y, t[3] = h * w + m * q + R * Y, t[4] = c * g + M * y + p * x, t[5] = f * g + l * y + d * x, t[6] = s * g + v * y + A * x, t[7] = h * g + m * y + R * x, t[8] = c * P + M * E + p * T, t[9] = f * P + l * E + d * T, t[10] = s * P + v * E + A * T, t[11] = h * P + m * E + R * T, n !== t && (t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]), t)
        }, e.rotateX = function (t, n, r) {
            var a = Math.sin(r),
                e = Math.cos(r),
                u = n[4],
                o = n[5],
                i = n[6],
                c = n[7],
                f = n[8],
                s = n[9],
                h = n[10],
                M = n[11];
            return n !== t && (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]), t[4] = u * e + f * a, t[5] = o * e + s * a, t[6] = i * e + h * a, t[7] = c * e + M * a, t[8] = f * e - u * a, t[9] = s * e - o * a, t[10] = h * e - i * a, t[11] = M * e - c * a, t
        }, e.rotateY = function (t, n, r) {
            var a = Math.sin(r),
                e = Math.cos(r),
                u = n[0],
                o = n[1],
                i = n[2],
                c = n[3],
                f = n[8],
                s = n[9],
                h = n[10],
                M = n[11];
            return n !== t && (t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]), t[0] = u * e - f * a, t[1] = o * e - s * a, t[2] = i * e - h * a, t[3] = c * e - M * a, t[8] = u * a + f * e, t[9] = o * a + s * e, t[10] = i * a + h * e, t[11] = c * a + M * e, t
        }, e.rotateZ = function (t, n, r) {
            var a = Math.sin(r),
                e = Math.cos(r),
                u = n[0],
                o = n[1],
                i = n[2],
                c = n[3],
                f = n[4],
                s = n[5],
                h = n[6],
                M = n[7];
            return n !== t && (t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]), t[0] = u * e + f * a, t[1] = o * e + s * a, t[2] = i * e + h * a, t[3] = c * e + M * a, t[4] = f * e - u * a, t[5] = s * e - o * a, t[6] = h * e - i * a, t[7] = M * e - c * a, t
        }, e.fromTranslation = function (t, n) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t
        }, e.fromScaling = function (t, n) {
            return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = n[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = n[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, e.fromRotation = function (t, n, r) {
            var e, u, o, i = r[0],
                c = r[1],
                f = r[2],
                s = Math.sqrt(i * i + c * c + f * f);
            return Math.abs(s) < a.EPSILON ? null : (s = 1 / s, i *= s, c *= s, f *= s, e = Math.sin(n), u = Math.cos(n), o = 1 - u, t[0] = i * i * o + u, t[1] = c * i * o + f * e, t[2] = f * i * o - c * e, t[3] = 0, t[4] = i * c * o - f * e, t[5] = c * c * o + u, t[6] = f * c * o + i * e, t[7] = 0, t[8] = i * f * o + c * e, t[9] = c * f * o - i * e, t[10] = f * f * o + u, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t)
        }, e.fromXRotation = function (t, n) {
            var r = Math.sin(n),
                a = Math.cos(n);
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = r, t[7] = 0, t[8] = 0, t[9] = -r, t[10] = a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, e.fromYRotation = function (t, n) {
            var r = Math.sin(n),
                a = Math.cos(n);
            return t[0] = a, t[1] = 0, t[2] = -r, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = r, t[9] = 0, t[10] = a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, e.fromZRotation = function (t, n) {
            var r = Math.sin(n),
                a = Math.cos(n);
            return t[0] = a, t[1] = r, t[2] = 0, t[3] = 0, t[4] = -r, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, e.fromRotationTranslation = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = a + a,
                c = e + e,
                f = u + u,
                s = a * i,
                h = a * c,
                M = a * f,
                l = e * c,
                v = e * f,
                m = u * f,
                p = o * i,
                d = o * c,
                A = o * f;
            return t[0] = 1 - (l + m), t[1] = h + A, t[2] = M - d, t[3] = 0, t[4] = h - A, t[5] = 1 - (s + m), t[6] = v + p, t[7] = 0, t[8] = M + d, t[9] = v - p, t[10] = 1 - (s + l), t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t
        }, e.fromRotationTranslationScale = function (t, n, r, a) {
            var e = n[0],
                u = n[1],
                o = n[2],
                i = n[3],
                c = e + e,
                f = u + u,
                s = o + o,
                h = e * c,
                M = e * f,
                l = e * s,
                v = u * f,
                m = u * s,
                p = o * s,
                d = i * c,
                A = i * f,
                R = i * s,
                w = a[0],
                q = a[1],
                Y = a[2];
            return t[0] = (1 - (v + p)) * w, t[1] = (M + R) * w, t[2] = (l - A) * w, t[3] = 0, t[4] = (M - R) * q, t[5] = (1 - (h + p)) * q, t[6] = (m + d) * q, t[7] = 0, t[8] = (l + A) * Y, t[9] = (m - d) * Y, t[10] = (1 - (h + v)) * Y, t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t
        }, e.fromRotationTranslationScaleOrigin = function (t, n, r, a, e) {
            var u = n[0],
                o = n[1],
                i = n[2],
                c = n[3],
                f = u + u,
                s = o + o,
                h = i + i,
                M = u * f,
                l = u * s,
                v = u * h,
                m = o * s,
                p = o * h,
                d = i * h,
                A = c * f,
                R = c * s,
                w = c * h,
                q = a[0],
                Y = a[1],
                g = a[2],
                y = e[0],
                x = e[1],
                P = e[2];
            return t[0] = (1 - (m + d)) * q, t[1] = (l + w) * q, t[2] = (v - R) * q, t[3] = 0, t[4] = (l - w) * Y, t[5] = (1 - (M + d)) * Y, t[6] = (p + A) * Y, t[7] = 0, t[8] = (v + R) * g, t[9] = (p - A) * g, t[10] = (1 - (M + m)) * g, t[11] = 0, t[12] = r[0] + y - (t[0] * y + t[4] * x + t[8] * P), t[13] = r[1] + x - (t[1] * y + t[5] * x + t[9] * P), t[14] = r[2] + P - (t[2] * y + t[6] * x + t[10] * P), t[15] = 1, t
        }, e.fromQuat = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = n[3],
                o = r + r,
                i = a + a,
                c = e + e,
                f = r * o,
                s = a * o,
                h = a * i,
                M = e * o,
                l = e * i,
                v = e * c,
                m = u * o,
                p = u * i,
                d = u * c;
            return t[0] = 1 - h - v, t[1] = s + d, t[2] = M - p, t[3] = 0, t[4] = s - d, t[5] = 1 - f - v, t[6] = l + m, t[7] = 0, t[8] = M + p, t[9] = l - m, t[10] = 1 - f - h, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, e.frustum = function (t, n, r, a, e, u, o) {
            var i = 1 / (r - n),
                c = 1 / (e - a),
                f = 1 / (u - o);
            return t[0] = 2 * u * i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * u * c, t[6] = 0, t[7] = 0, t[8] = (r + n) * i, t[9] = (e + a) * c, t[10] = (o + u) * f, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = o * u * 2 * f, t[15] = 0, t
        }, e.perspective = function (t, n, r, a, e) {
            var u = 1 / Math.tan(n / 2),
                o = 1 / (a - e);
            return t[0] = u / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = u, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = (e + a) * o, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = 2 * e * a * o, t[15] = 0, t
        }, e.perspectiveFromFieldOfView = function (t, n, r, a) {
            var e = Math.tan(n.upDegrees * Math.PI / 180),
                u = Math.tan(n.downDegrees * Math.PI / 180),
                o = Math.tan(n.leftDegrees * Math.PI / 180),
                i = Math.tan(n.rightDegrees * Math.PI / 180),
                c = 2 / (o + i),
                f = 2 / (e + u);
            return t[0] = c, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = f, t[6] = 0, t[7] = 0, t[8] = -((o - i) * c * .5), t[9] = (e - u) * f * .5, t[10] = a / (r - a), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = a * r / (r - a), t[15] = 0, t
        }, e.ortho = function (t, n, r, a, e, u, o) {
            var i = 1 / (n - r),
                c = 1 / (a - e),
                f = 1 / (u - o);
            return t[0] = -2 * i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * c, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * f, t[11] = 0, t[12] = (n + r) * i, t[13] = (e + a) * c, t[14] = (o + u) * f, t[15] = 1, t
        }, e.lookAt = function (t, n, r, u) {
            var o, i, c, f, s, h, M, l, v, m, p = n[0],
                d = n[1],
                A = n[2],
                R = u[0],
                w = u[1],
                q = u[2],
                Y = r[0],
                g = r[1],
                y = r[2];
            return Math.abs(p - Y) < a.EPSILON && Math.abs(d - g) < a.EPSILON && Math.abs(A - y) < a.EPSILON ? e.identity(t) : (M = p - Y, l = d - g, v = A - y, m = 1 / Math.sqrt(M * M + l * l + v * v), M *= m, l *= m, v *= m, o = w * v - q * l, i = q * M - R * v, c = R * l - w * M, m = Math.sqrt(o * o + i * i + c * c), m ? (m = 1 / m, o *= m, i *= m, c *= m) : (o = 0, i = 0, c = 0), f = l * c - v * i, s = v * o - M * c, h = M * i - l * o, m = Math.sqrt(f * f + s * s + h * h), m ? (m = 1 / m, f *= m, s *= m, h *= m) : (f = 0, s = 0, h = 0), t[0] = o, t[1] = f, t[2] = M, t[3] = 0, t[4] = i, t[5] = s, t[6] = l, t[7] = 0, t[8] = c, t[9] = h, t[10] = v, t[11] = 0, t[12] = -(o * p + i * d + c * A), t[13] = -(f * p + s * d + h * A), t[14] = -(M * p + l * d + v * A), t[15] = 1, t)
        }, e.str = function (t) {
            return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")"
        }, e.frob = function (t) {
            return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2) + Math.pow(t[9], 2) + Math.pow(t[10], 2) + Math.pow(t[11], 2) + Math.pow(t[12], 2) + Math.pow(t[13], 2) + Math.pow(t[14], 2) + Math.pow(t[15], 2))
        }, t.exports = e
    }, function (t, n, r) {
        var a = r(1),
            e = r(4),
            u = r(7),
            o = r(8),
            i = {};
        i.create = function () {
            var t = new a.ARRAY_TYPE(4);
            return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t
        }, i.rotationTo = function () {
            var t = u.create(),
                n = u.fromValues(1, 0, 0),
                r = u.fromValues(0, 1, 0);
            return function (a, e, o) {
                var c = u.dot(e, o);
                return -.999999 > c ? (u.cross(t, n, e), u.length(t) < 1e-6 && u.cross(t, r, e), u.normalize(t, t), i.setAxisAngle(a, t, Math.PI), a) : c > .999999 ? (a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a) : (u.cross(t, e, o), a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = 1 + c, i.normalize(a, a))
            }
        }(), i.setAxes = function () {
            var t = e.create();
            return function (n, r, a, e) {
                return t[0] = a[0], t[3] = a[1], t[6] = a[2], t[1] = e[0], t[4] = e[1], t[7] = e[2], t[2] = -r[0], t[5] = -r[1], t[8] = -r[2], i.normalize(n, i.fromMat3(n, t))
            }
        }(), i.clone = o.clone, i.fromValues = o.fromValues, i.copy = o.copy, i.set = o.set, i.identity = function (t) {
            return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t
        }, i.setAxisAngle = function (t, n, r) {
            r = .5 * r;
            var a = Math.sin(r);
            return t[0] = a * n[0], t[1] = a * n[1], t[2] = a * n[2], t[3] = Math.cos(r), t
        }, i.add = o.add, i.multiply = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = r[0],
                c = r[1],
                f = r[2],
                s = r[3];
            return t[0] = a * s + o * i + e * f - u * c, t[1] = e * s + o * c + u * i - a * f, t[2] = u * s + o * f + a * c - e * i, t[3] = o * s - a * i - e * c - u * f, t
        }, i.mul = i.multiply, i.scale = o.scale, i.rotateX = function (t, n, r) {
            r *= .5;
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = Math.sin(r),
                c = Math.cos(r);
            return t[0] = a * c + o * i, t[1] = e * c + u * i, t[2] = u * c - e * i, t[3] = o * c - a * i, t
        }, i.rotateY = function (t, n, r) {
            r *= .5;
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = Math.sin(r),
                c = Math.cos(r);
            return t[0] = a * c - u * i, t[1] = e * c + o * i, t[2] = u * c + a * i, t[3] = o * c - e * i, t
        }, i.rotateZ = function (t, n, r) {
            r *= .5;
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3],
                i = Math.sin(r),
                c = Math.cos(r);
            return t[0] = a * c + e * i, t[1] = e * c - a * i, t[2] = u * c + o * i, t[3] = o * c - u * i, t
        }, i.calculateW = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2];
            return t[0] = r, t[1] = a, t[2] = e, t[3] = Math.sqrt(Math.abs(1 - r * r - a * a - e * e)), t
        }, i.dot = o.dot, i.lerp = o.lerp, i.slerp = function (t, n, r, a) {
            var e, u, o, i, c, f = n[0],
                s = n[1],
                h = n[2],
                M = n[3],
                l = r[0],
                v = r[1],
                m = r[2],
                p = r[3];
            return u = f * l + s * v + h * m + M * p, 0 > u && (u = -u, l = -l, v = -v, m = -m, p = -p), 1 - u > 1e-6 ? (e = Math.acos(u), o = Math.sin(e), i = Math.sin((1 - a) * e) / o, c = Math.sin(a * e) / o) : (i = 1 - a, c = a), t[0] = i * f + c * l, t[1] = i * s + c * v, t[2] = i * h + c * m, t[3] = i * M + c * p, t
        }, i.sqlerp = function () {
            var t = i.create(),
                n = i.create();
            return function (r, a, e, u, o, c) {
                return i.slerp(t, a, o, c), i.slerp(n, e, u, c), i.slerp(r, t, n, 2 * c * (1 - c)), r
            }
        }(), i.invert = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = n[3],
                o = r * r + a * a + e * e + u * u,
                i = o ? 1 / o : 0;
            return t[0] = -r * i, t[1] = -a * i, t[2] = -e * i, t[3] = u * i, t
        }, i.conjugate = function (t, n) {
            return t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t[3] = n[3], t
        }, i.length = o.length, i.len = i.length, i.squaredLength = o.squaredLength, i.sqrLen = i.squaredLength, i.normalize = o.normalize, i.fromMat3 = function (t, n) {
            var r, a = n[0] + n[4] + n[8];
            if (a > 0) r = Math.sqrt(a + 1), t[3] = .5 * r, r = .5 / r, t[0] = (n[5] - n[7]) * r, t[1] = (n[6] - n[2]) * r, t[2] = (n[1] - n[3]) * r;
            else {
                var e = 0;
                n[4] > n[0] && (e = 1), n[8] > n[3 * e + e] && (e = 2);
                var u = (e + 1) % 3,
                    o = (e + 2) % 3;
                r = Math.sqrt(n[3 * e + e] - n[3 * u + u] - n[3 * o + o] + 1), t[e] = .5 * r, r = .5 / r, t[3] = (n[3 * u + o] - n[3 * o + u]) * r, t[u] = (n[3 * u + e] + n[3 * e + u]) * r, t[o] = (n[3 * o + e] + n[3 * e + o]) * r
            }
            return t
        }, i.str = function (t) {
            return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
        }, t.exports = i
    }, function (t, n, r) {
        var a = r(1),
            e = {};
        e.create = function () {
            var t = new a.ARRAY_TYPE(3);
            return t[0] = 0, t[1] = 0, t[2] = 0, t
        }, e.clone = function (t) {
            var n = new a.ARRAY_TYPE(3);
            return n[0] = t[0], n[1] = t[1], n[2] = t[2], n
        }, e.fromValues = function (t, n, r) {
            var e = new a.ARRAY_TYPE(3);
            return e[0] = t, e[1] = n, e[2] = r, e
        }, e.copy = function (t, n) {
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t
        }, e.set = function (t, n, r, a) {
            return t[0] = n, t[1] = r, t[2] = a, t
        }, e.add = function (t, n, r) {
            return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t
        }, e.subtract = function (t, n, r) {
            return t[0] = n[0] - r[0], t[1] = n[1] - r[1], t[2] = n[2] - r[2], t
        }, e.sub = e.subtract, e.multiply = function (t, n, r) {
            return t[0] = n[0] * r[0], t[1] = n[1] * r[1], t[2] = n[2] * r[2], t
        }, e.mul = e.multiply, e.divide = function (t, n, r) {
            return t[0] = n[0] / r[0], t[1] = n[1] / r[1], t[2] = n[2] / r[2], t
        }, e.div = e.divide, e.min = function (t, n, r) {
            return t[0] = Math.min(n[0], r[0]), t[1] = Math.min(n[1], r[1]), t[2] = Math.min(n[2], r[2]), t
        }, e.max = function (t, n, r) {
            return t[0] = Math.max(n[0], r[0]), t[1] = Math.max(n[1], r[1]), t[2] = Math.max(n[2], r[2]), t
        }, e.scale = function (t, n, r) {
            return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t
        }, e.scaleAndAdd = function (t, n, r, a) {
            return t[0] = n[0] + r[0] * a, t[1] = n[1] + r[1] * a, t[2] = n[2] + r[2] * a, t
        }, e.distance = function (t, n) {
            var r = n[0] - t[0],
                a = n[1] - t[1],
                e = n[2] - t[2];
            return Math.sqrt(r * r + a * a + e * e)
        }, e.dist = e.distance, e.squaredDistance = function (t, n) {
            var r = n[0] - t[0],
                a = n[1] - t[1],
                e = n[2] - t[2];
            return r * r + a * a + e * e
        }, e.sqrDist = e.squaredDistance, e.length = function (t) {
            var n = t[0],
                r = t[1],
                a = t[2];
            return Math.sqrt(n * n + r * r + a * a)
        }, e.len = e.length, e.squaredLength = function (t) {
            var n = t[0],
                r = t[1],
                a = t[2];
            return n * n + r * r + a * a
        }, e.sqrLen = e.squaredLength, e.negate = function (t, n) {
            return t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t
        }, e.inverse = function (t, n) {
            return t[0] = 1 / n[0], t[1] = 1 / n[1], t[2] = 1 / n[2], t
        }, e.normalize = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = r * r + a * a + e * e;
            return u > 0 && (u = 1 / Math.sqrt(u), t[0] = n[0] * u, t[1] = n[1] * u, t[2] = n[2] * u), t
        }, e.dot = function (t, n) {
            return t[0] * n[0] + t[1] * n[1] + t[2] * n[2]
        }, e.cross = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = r[0],
                i = r[1],
                c = r[2];
            return t[0] = e * c - u * i, t[1] = u * o - a * c, t[2] = a * i - e * o, t
        }, e.lerp = function (t, n, r, a) {
            var e = n[0],
                u = n[1],
                o = n[2];
            return t[0] = e + a * (r[0] - e), t[1] = u + a * (r[1] - u), t[2] = o + a * (r[2] - o), t
        }, e.hermite = function (t, n, r, a, e, u) {
            var o = u * u,
                i = o * (2 * u - 3) + 1,
                c = o * (u - 2) + u,
                f = o * (u - 1),
                s = o * (3 - 2 * u);
            return t[0] = n[0] * i + r[0] * c + a[0] * f + e[0] * s, t[1] = n[1] * i + r[1] * c + a[1] * f + e[1] * s, t[2] = n[2] * i + r[2] * c + a[2] * f + e[2] * s, t
        }, e.bezier = function (t, n, r, a, e, u) {
            var o = 1 - u,
                i = o * o,
                c = u * u,
                f = i * o,
                s = 3 * u * i,
                h = 3 * c * o,
                M = c * u;
            return t[0] = n[0] * f + r[0] * s + a[0] * h + e[0] * M, t[1] = n[1] * f + r[1] * s + a[1] * h + e[1] * M, t[2] = n[2] * f + r[2] * s + a[2] * h + e[2] * M, t
        }, e.random = function (t, n) {
            n = n || 1;
            var r = 2 * a.RANDOM() * Math.PI,
                e = 2 * a.RANDOM() - 1,
                u = Math.sqrt(1 - e * e) * n;
            return t[0] = Math.cos(r) * u, t[1] = Math.sin(r) * u, t[2] = e * n, t
        }, e.transformMat4 = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = r[3] * a + r[7] * e + r[11] * u + r[15];
            return o = o || 1, t[0] = (r[0] * a + r[4] * e + r[8] * u + r[12]) / o, t[1] = (r[1] * a + r[5] * e + r[9] * u + r[13]) / o, t[2] = (r[2] * a + r[6] * e + r[10] * u + r[14]) / o, t
        }, e.transformMat3 = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2];
            return t[0] = a * r[0] + e * r[3] + u * r[6], t[1] = a * r[1] + e * r[4] + u * r[7], t[2] = a * r[2] + e * r[5] + u * r[8], t
        }, e.transformQuat = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = r[0],
                i = r[1],
                c = r[2],
                f = r[3],
                s = f * a + i * u - c * e,
                h = f * e + c * a - o * u,
                M = f * u + o * e - i * a,
                l = -o * a - i * e - c * u;
            return t[0] = s * f + l * -o + h * -c - M * -i, t[1] = h * f + l * -i + M * -o - s * -c, t[2] = M * f + l * -c + s * -i - h * -o, t
        }, e.rotateX = function (t, n, r, a) {
            var e = [],
                u = [];
            return e[0] = n[0] - r[0], e[1] = n[1] - r[1], e[2] = n[2] - r[2], u[0] = e[0], u[1] = e[1] * Math.cos(a) - e[2] * Math.sin(a), u[2] = e[1] * Math.sin(a) + e[2] * Math.cos(a), t[0] = u[0] + r[0], t[1] = u[1] + r[1], t[2] = u[2] + r[2], t
        }, e.rotateY = function (t, n, r, a) {
            var e = [],
                u = [];
            return e[0] = n[0] - r[0], e[1] = n[1] - r[1], e[2] = n[2] - r[2], u[0] = e[2] * Math.sin(a) + e[0] * Math.cos(a), u[1] = e[1], u[2] = e[2] * Math.cos(a) - e[0] * Math.sin(a), t[0] = u[0] + r[0], t[1] = u[1] + r[1], t[2] = u[2] + r[2], t
        }, e.rotateZ = function (t, n, r, a) {
            var e = [],
                u = [];
            return e[0] = n[0] - r[0], e[1] = n[1] - r[1], e[2] = n[2] - r[2], u[0] = e[0] * Math.cos(a) - e[1] * Math.sin(a), u[1] = e[0] * Math.sin(a) + e[1] * Math.cos(a), u[2] = e[2], t[0] = u[0] + r[0], t[1] = u[1] + r[1], t[2] = u[2] + r[2], t
        }, e.forEach = function () {
            var t = e.create();
            return function (n, r, a, e, u, o) {
                var i, c;
                for (r || (r = 3), a || (a = 0), c = e ? Math.min(e * r + a, n.length) : n.length, i = a; c > i; i += r) t[0] = n[i], t[1] = n[i + 1], t[2] = n[i + 2], u(t, t, o), n[i] = t[0], n[i + 1] = t[1], n[i + 2] = t[2];
                return n
            }
        }(), e.angle = function (t, n) {
            var r = e.fromValues(t[0], t[1], t[2]),
                a = e.fromValues(n[0], n[1], n[2]);
            e.normalize(r, r), e.normalize(a, a);
            var u = e.dot(r, a);
            return u > 1 ? 0 : Math.acos(u)
        }, e.str = function (t) {
            return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")"
        }, t.exports = e
    }, function (t, n, r) {
        var a = r(1),
            e = {};
        e.create = function () {
            var t = new a.ARRAY_TYPE(4);
            return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t
        }, e.clone = function (t) {
            var n = new a.ARRAY_TYPE(4);
            return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n
        }, e.fromValues = function (t, n, r, e) {
            var u = new a.ARRAY_TYPE(4);
            return u[0] = t, u[1] = n, u[2] = r, u[3] = e, u
        }, e.copy = function (t, n) {
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t
        }, e.set = function (t, n, r, a, e) {
            return t[0] = n, t[1] = r, t[2] = a, t[3] = e, t
        }, e.add = function (t, n, r) {
            return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t[3] = n[3] + r[3], t
        }, e.subtract = function (t, n, r) {
            return t[0] = n[0] - r[0], t[1] = n[1] - r[1], t[2] = n[2] - r[2], t[3] = n[3] - r[3], t
        }, e.sub = e.subtract, e.multiply = function (t, n, r) {
            return t[0] = n[0] * r[0], t[1] = n[1] * r[1], t[2] = n[2] * r[2], t[3] = n[3] * r[3], t
        }, e.mul = e.multiply, e.divide = function (t, n, r) {
            return t[0] = n[0] / r[0], t[1] = n[1] / r[1], t[2] = n[2] / r[2], t[3] = n[3] / r[3], t
        }, e.div = e.divide, e.min = function (t, n, r) {
            return t[0] = Math.min(n[0], r[0]), t[1] = Math.min(n[1], r[1]), t[2] = Math.min(n[2], r[2]), t[3] = Math.min(n[3], r[3]), t
        }, e.max = function (t, n, r) {
            return t[0] = Math.max(n[0], r[0]), t[1] = Math.max(n[1], r[1]), t[2] = Math.max(n[2], r[2]), t[3] = Math.max(n[3], r[3]), t
        }, e.scale = function (t, n, r) {
            return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = n[3] * r, t
        }, e.scaleAndAdd = function (t, n, r, a) {
            return t[0] = n[0] + r[0] * a, t[1] = n[1] + r[1] * a, t[2] = n[2] + r[2] * a, t[3] = n[3] + r[3] * a, t
        }, e.distance = function (t, n) {
            var r = n[0] - t[0],
                a = n[1] - t[1],
                e = n[2] - t[2],
                u = n[3] - t[3];
            return Math.sqrt(r * r + a * a + e * e + u * u)
        }, e.dist = e.distance, e.squaredDistance = function (t, n) {
            var r = n[0] - t[0],
                a = n[1] - t[1],
                e = n[2] - t[2],
                u = n[3] - t[3];
            return r * r + a * a + e * e + u * u
        }, e.sqrDist = e.squaredDistance, e.length = function (t) {
            var n = t[0],
                r = t[1],
                a = t[2],
                e = t[3];
            return Math.sqrt(n * n + r * r + a * a + e * e)
        }, e.len = e.length, e.squaredLength = function (t) {
            var n = t[0],
                r = t[1],
                a = t[2],
                e = t[3];
            return n * n + r * r + a * a + e * e
        }, e.sqrLen = e.squaredLength, e.negate = function (t, n) {
            return t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t[3] = -n[3], t
        }, e.inverse = function (t, n) {
            return t[0] = 1 / n[0], t[1] = 1 / n[1], t[2] = 1 / n[2], t[3] = 1 / n[3], t
        }, e.normalize = function (t, n) {
            var r = n[0],
                a = n[1],
                e = n[2],
                u = n[3],
                o = r * r + a * a + e * e + u * u;
            return o > 0 && (o = 1 / Math.sqrt(o), t[0] = r * o, t[1] = a * o, t[2] = e * o, t[3] = u * o), t
        }, e.dot = function (t, n) {
            return t[0] * n[0] + t[1] * n[1] + t[2] * n[2] + t[3] * n[3]
        }, e.lerp = function (t, n, r, a) {
            var e = n[0],
                u = n[1],
                o = n[2],
                i = n[3];
            return t[0] = e + a * (r[0] - e), t[1] = u + a * (r[1] - u), t[2] = o + a * (r[2] - o), t[3] = i + a * (r[3] - i), t
        }, e.random = function (t, n) {
            return n = n || 1, t[0] = a.RANDOM(), t[1] = a.RANDOM(), t[2] = a.RANDOM(), t[3] = a.RANDOM(), e.normalize(t, t), e.scale(t, t, n), t
        }, e.transformMat4 = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = n[3];
            return t[0] = r[0] * a + r[4] * e + r[8] * u + r[12] * o, t[1] = r[1] * a + r[5] * e + r[9] * u + r[13] * o, t[2] = r[2] * a + r[6] * e + r[10] * u + r[14] * o, t[3] = r[3] * a + r[7] * e + r[11] * u + r[15] * o, t
        }, e.transformQuat = function (t, n, r) {
            var a = n[0],
                e = n[1],
                u = n[2],
                o = r[0],
                i = r[1],
                c = r[2],
                f = r[3],
                s = f * a + i * u - c * e,
                h = f * e + c * a - o * u,
                M = f * u + o * e - i * a,
                l = -o * a - i * e - c * u;
            return t[0] = s * f + l * -o + h * -c - M * -i, t[1] = h * f + l * -i + M * -o - s * -c, t[2] = M * f + l * -c + s * -i - h * -o, t[3] = n[3], t
        }, e.forEach = function () {
            var t = e.create();
            return function (n, r, a, e, u, o) {
                var i, c;
                for (r || (r = 4), a || (a = 0), c = e ? Math.min(e * r + a, n.length) : n.length, i = a; c > i; i += r) t[0] = n[i], t[1] = n[i + 1], t[2] = n[i + 2], t[3] = n[i + 3], u(t, t, o), n[i] = t[0], n[i + 1] = t[1], n[i + 2] = t[2], n[i + 3] = t[3];
                return n
            }
        }(), e.str = function (t) {
            return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
        }, t.exports = e
    }, function (t, n, r) {
        var a = r(1),
            e = {};
        e.create = function () {
            var t = new a.ARRAY_TYPE(2);
            return t[0] = 0, t[1] = 0, t
        }, e.clone = function (t) {
            var n = new a.ARRAY_TYPE(2);
            return n[0] = t[0], n[1] = t[1], n
        }, e.fromValues = function (t, n) {
            var r = new a.ARRAY_TYPE(2);
            return r[0] = t, r[1] = n, r
        }, e.copy = function (t, n) {
            return t[0] = n[0], t[1] = n[1], t
        }, e.set = function (t, n, r) {
            return t[0] = n, t[1] = r, t
        }, e.add = function (t, n, r) {
            return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t
        }, e.subtract = function (t, n, r) {
            return t[0] = n[0] - r[0], t[1] = n[1] - r[1], t
        }, e.sub = e.subtract, e.multiply = function (t, n, r) {
            return t[0] = n[0] * r[0], t[1] = n[1] * r[1], t
        }, e.mul = e.multiply, e.divide = function (t, n, r) {
            return t[0] = n[0] / r[0], t[1] = n[1] / r[1], t
        }, e.div = e.divide, e.min = function (t, n, r) {
            return t[0] = Math.min(n[0], r[0]), t[1] = Math.min(n[1], r[1]), t
        }, e.max = function (t, n, r) {
            return t[0] = Math.max(n[0], r[0]), t[1] = Math.max(n[1], r[1]), t
        }, e.scale = function (t, n, r) {
            return t[0] = n[0] * r, t[1] = n[1] * r, t
        }, e.scaleAndAdd = function (t, n, r, a) {
            return t[0] = n[0] + r[0] * a, t[1] = n[1] + r[1] * a, t
        }, e.distance = function (t, n) {
            var r = n[0] - t[0],
                a = n[1] - t[1];
            return Math.sqrt(r * r + a * a)
        }, e.dist = e.distance, e.squaredDistance = function (t, n) {
            var r = n[0] - t[0],
                a = n[1] - t[1];
            return r * r + a * a
        }, e.sqrDist = e.squaredDistance, e.length = function (t) {
            var n = t[0],
                r = t[1];
            return Math.sqrt(n * n + r * r)
        }, e.len = e.length, e.squaredLength = function (t) {
            var n = t[0],
                r = t[1];
            return n * n + r * r
        }, e.sqrLen = e.squaredLength, e.negate = function (t, n) {
            return t[0] = -n[0], t[1] = -n[1], t
        }, e.inverse = function (t, n) {
            return t[0] = 1 / n[0], t[1] = 1 / n[1], t
        }, e.normalize = function (t, n) {
            var r = n[0],
                a = n[1],
                e = r * r + a * a;
            return e > 0 && (e = 1 / Math.sqrt(e), t[0] = n[0] * e, t[1] = n[1] * e), t
        }, e.dot = function (t, n) {
            return t[0] * n[0] + t[1] * n[1]
        }, e.cross = function (t, n, r) {
            var a = n[0] * r[1] - n[1] * r[0];
            return t[0] = t[1] = 0, t[2] = a, t
        }, e.lerp = function (t, n, r, a) {
            var e = n[0],
                u = n[1];
            return t[0] = e + a * (r[0] - e), t[1] = u + a * (r[1] - u), t
        }, e.random = function (t, n) {
            n = n || 1;
            var r = 2 * a.RANDOM() * Math.PI;
            return t[0] = Math.cos(r) * n, t[1] = Math.sin(r) * n, t
        }, e.transformMat2 = function (t, n, r) {
            var a = n[0],
                e = n[1];
            return t[0] = r[0] * a + r[2] * e, t[1] = r[1] * a + r[3] * e, t
        }, e.transformMat2d = function (t, n, r) {
            var a = n[0],
                e = n[1];
            return t[0] = r[0] * a + r[2] * e + r[4], t[1] = r[1] * a + r[3] * e + r[5], t
        }, e.transformMat3 = function (t, n, r) {
            var a = n[0],
                e = n[1];
            return t[0] = r[0] * a + r[3] * e + r[6], t[1] = r[1] * a + r[4] * e + r[7], t
        }, e.transformMat4 = function (t, n, r) {
            var a = n[0],
                e = n[1];
            return t[0] = r[0] * a + r[4] * e + r[12], t[1] = r[1] * a + r[5] * e + r[13], t
        }, e.forEach = function () {
            var t = e.create();
            return function (n, r, a, e, u, o) {
                var i, c;
                for (r || (r = 2), a || (a = 0), c = e ? Math.min(e * r + a, n.length) : n.length, i = a; c > i; i += r) t[0] = n[i], t[1] = n[i + 1], u(t, t, o), n[i] = t[0], n[i + 1] = t[1];
                return n
            }
        }(), e.str = function (t) {
            return "vec2(" + t[0] + ", " + t[1] + ")"
        }, t.exports = e
    }])
});
/*Copyright (c) 2015, Mapbox
Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
*/
! function (e) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = e();
    else if ("function" == typeof define && define.amd) define([], e);
    else {
        var n;
        n = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, n.earcut = e()
    }
}(function () {
    return function e(n, t, r) {
        function x(u, f) {
            if (!t[u]) {
                if (!n[u]) {
                    var o = "function" == typeof require && require;
                    if (!f && o) return o(u, !0);
                    if (i) return i(u, !0);
                    var v = new Error("Cannot find module '" + u + "'");
                    throw v.code = "MODULE_NOT_FOUND", v
                }
                var y = t[u] = {
                    exports: {}
                };
                n[u][0].call(y.exports, function (e) {
                    var t = n[u][1][e];
                    return x(t ? t : e)
                }, y, y.exports, e, n, t, r)
            }
            return t[u].exports
        }
        for (var i = "function" == typeof require && require, u = 0; u < r.length; u++) x(r[u]);
        return x
    }({
        1: [function (e, n, t) {
            "use strict";

            function r(e, n, t) {
                t = t || 2;
                var r = n && n.length,
                    f = r ? n[0] * t : e.length,
                    o = i(x(e, 0, f, t, !0)),
                    v = [];
                if (!o) return v;
                var y, l, a, c, s, h, d;
                if (r && (o = p(e, n, o, t)), e.length > 80 * t) {
                    y = a = e[0], l = c = e[1];
                    for (var Z = t; f > Z; Z += t) s = e[Z], h = e[Z + 1], y > s && (y = s), l > h && (l = h), s > a && (a = s), h > c && (c = h);
                    d = Math.max(a - y, c - l)
                }
                return u(o, v, t, y, l, d), v
            }

            function x(e, n, t, r, x) {
                var i, u, f, o = 0;
                for (i = n, u = t - r; t > i; i += r) o += (e[u] - e[i]) * (e[i + 1] + e[u + 1]), u = i;
                if (x === o > 0)
                    for (i = n; t > i; i += r) f = E(i, e[i], e[i + 1], f);
                else
                    for (i = t - r; i >= n; i -= r) f = E(i, e[i], e[i + 1], f);
                return f
            }

            function i(e, n) {
                if (!e) return e;
                n || (n = e);
                var t, r = e;
                do
                    if (t = !1, r.steiner || !b(r, r.next) && 0 !== z(r.prev, r, r.next)) r = r.next;
                    else {
                        if (N(r), r = n = r.prev, r === r.next) return null;
                        t = !0
                    }
                while (t || r !== n);
                return n
            }

            function u(e, n, t, r, x, p, l) {
                if (e) {
                    !l && p && s(e, r, x, p);
                    for (var a, c, h = e; e.prev !== e.next;)
                        if (a = e.prev, c = e.next, p ? o(e, r, x, p) : f(e)) n.push(a.i / t), n.push(e.i / t), n.push(c.i / t), N(e), e = c.next, h = c.next;
                        else if (e = c, e === h) {
                        l ? 1 === l ? (e = v(e, n, t), u(e, n, t, r, x, p, 2)) : 2 === l && y(e, n, t, r, x, p) : u(i(e), n, t, r, x, p, 1);
                        break
                    }
                }
            }

            function f(e) {
                var n = e.prev,
                    t = e,
                    r = e.next;
                if (z(n, t, r) >= 0) return !1;
                for (var x = e.next.next; x !== e.prev;) {
                    if (w(n.x, n.y, t.x, t.y, r.x, r.y, x.x, x.y) && z(x.prev, x, x.next) >= 0) return !1;
                    x = x.next
                }
                return !0
            }

            function o(e, n, t, r) {
                var x = e.prev,
                    i = e,
                    u = e.next;
                if (z(x, i, u) >= 0) return !1;
                for (var f = x.x < i.x ? x.x < u.x ? x.x : u.x : i.x < u.x ? i.x : u.x, o = x.y < i.y ? x.y < u.y ? x.y : u.y : i.y < u.y ? i.y : u.y, v = x.x > i.x ? x.x > u.x ? x.x : u.x : i.x > u.x ? i.x : u.x, y = x.y > i.y ? x.y > u.y ? x.y : u.y : i.y > u.y ? i.y : u.y, p = d(f, o, n, t, r), l = d(v, y, n, t, r), a = e.nextZ; a && a.z <= l;) {
                    if (a !== e.prev && a !== e.next && w(x.x, x.y, i.x, i.y, u.x, u.y, a.x, a.y) && z(a.prev, a, a.next) >= 0) return !1;
                    a = a.nextZ
                }
                for (a = e.prevZ; a && a.z >= p;) {
                    if (a !== e.prev && a !== e.next && w(x.x, x.y, i.x, i.y, u.x, u.y, a.x, a.y) && z(a.prev, a, a.next) >= 0) return !1;
                    a = a.prevZ
                }
                return !0
            }

            function v(e, n, t) {
                var r = e;
                do {
                    var x = r.prev,
                        i = r.next.next;
                    m(x, r, r.next, i) && M(x, i) && M(i, x) && (n.push(x.i / t), n.push(r.i / t), n.push(i.i / t), N(r), N(r.next), r = e = i), r = r.next
                } while (r !== e);
                return r
            }

            function y(e, n, t, r, x, f) {
                var o = e;
                do {
                    for (var v = o.next.next; v !== o.prev;) {
                        if (o.i !== v.i && g(o, v)) {
                            var y = D(o, v);
                            return o = i(o, o.next), y = i(y, y.next), u(o, n, t, r, x, f), void u(y, n, t, r, x, f)
                        }
                        v = v.next
                    }
                    o = o.next
                } while (o !== e)
            }

            function p(e, n, t, r) {
                var u, f, o, v, y, p = [];
                for (u = 0, f = n.length; f > u; u++) o = n[u] * r, v = f - 1 > u ? n[u + 1] * r : e.length, y = x(e, o, v, r, !1), y === y.next && (y.steiner = !0), y = i(y), y && p.push(Z(y));
                for (p.sort(l), u = 0; u < p.length; u++) a(p[u], t), t = i(t, t.next);
                return t
            }

            function l(e, n) {
                return e.x - n.x
            }

            function a(e, n) {
                if (n = c(e, n)) {
                    var t = D(n, e);
                    i(t, t.next)
                }
            }

            function c(e, n) {
                var t, r = n,
                    x = e.x,
                    i = e.y,
                    u = -(1 / 0);
                do {
                    if (i <= r.y && i >= r.next.y) {
                        var f = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        x >= f && f > u && (u = f, t = r.x < r.next.x ? r : r.next)
                    }
                    r = r.next
                } while (r !== n);
                if (!t) return null;
                var o, v = t,
                    y = 1 / 0;
                for (r = t.next; r !== v;) x >= r.x && r.x >= t.x && w(i < t.y ? x : u, i, t.x, t.y, i < t.y ? u : x, i, r.x, r.y) && (o = Math.abs(i - r.y) / (x - r.x), (y > o || o === y && r.x > t.x) && M(r, e) && (t = r, y = o)), r = r.next;
                return t
            }

            function s(e, n, t, r) {
                var x = e;
                do null === x.z && (x.z = d(x.x, x.y, n, t, r)), x.prevZ = x.prev, x.nextZ = x.next, x = x.next; while (x !== e);
                x.prevZ.nextZ = null, x.prevZ = null, h(x)
            }

            function h(e) {
                var n, t, r, x, i, u, f, o, v = 1;
                do {
                    for (t = e, e = null, i = null, u = 0; t;) {
                        for (u++, r = t, f = 0, n = 0; v > n && (f++, r = r.nextZ, r); n++);
                        for (o = v; f > 0 || o > 0 && r;) 0 === f ? (x = r, r = r.nextZ, o--) : 0 !== o && r ? t.z <= r.z ? (x = t, t = t.nextZ, f--) : (x = r, r = r.nextZ, o--) : (x = t, t = t.nextZ, f--), i ? i.nextZ = x : e = x, x.prevZ = i, i = x;
                        t = r
                    }
                    i.nextZ = null, v *= 2
                } while (u > 1);
                return e
            }

            function d(e, n, t, r, x) {
                return e = 32767 * (e - t) / x, n = 32767 * (n - r) / x, e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), n = 16711935 & (n | n << 8), n = 252645135 & (n | n << 4), n = 858993459 & (n | n << 2), n = 1431655765 & (n | n << 1), e | n << 1
            }

            function Z(e) {
                var n = e,
                    t = e;
                do n.x < t.x && (t = n), n = n.next; while (n !== e);
                return t
            }

            function w(e, n, t, r, x, i, u, f) {
                return (x - u) * (n - f) - (e - u) * (i - f) >= 0 && (e - u) * (r - f) - (t - u) * (n - f) >= 0 && (t - u) * (i - f) - (x - u) * (r - f) >= 0
            }

            function g(e, n) {
                return b(e, n) || e.next.i !== n.i && e.prev.i !== n.i && !q(e, n) && M(e, n) && M(n, e) && O(e, n)
            }

            function z(e, n, t) {
                return (n.y - e.y) * (t.x - n.x) - (n.x - e.x) * (t.y - n.y)
            }

            function b(e, n) {
                return e.x === n.x && e.y === n.y
            }

            function m(e, n, t, r) {
                return z(e, n, t) > 0 != z(e, n, r) > 0 && z(t, r, e) > 0 != z(t, r, n) > 0
            }

            function q(e, n) {
                var t = e;
                do {
                    if (t.i !== e.i && t.next.i !== e.i && t.i !== n.i && t.next.i !== n.i && m(t, t.next, e, n)) return !0;
                    t = t.next
                } while (t !== e);
                return !1
            }

            function M(e, n) {
                return z(e.prev, e, e.next) < 0 ? z(e, n, e.next) >= 0 && z(e, e.prev, n) >= 0 : z(e, n, e.prev) < 0 || z(e, e.next, n) < 0
            }

            function O(e, n) {
                var t = e,
                    r = !1,
                    x = (e.x + n.x) / 2,
                    i = (e.y + n.y) / 2;
                do t.y > i != t.next.y > i && x < (t.next.x - t.x) * (i - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next; while (t !== e);
                return r
            }

            function D(e, n) {
                var t = new U(e.i, e.x, e.y),
                    r = new U(n.i, n.x, n.y),
                    x = e.next,
                    i = n.prev;
                return e.next = n, n.prev = e, t.next = x, x.prev = t, r.next = t, t.prev = r, i.next = r, r.prev = i, r
            }

            function E(e, n, t, r) {
                var x = new U(e, n, t);
                return r ? (x.next = r.next, x.prev = r, r.next.prev = x, r.next = x) : (x.prev = x, x.next = x), x
            }

            function N(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function U(e, n, t) {
                this.i = e, this.x = n, this.y = t, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            n.exports = r
        }, {}]
    }, {}, [1])(1)
});
/*The MIT License (MIT)
Copyright (c) 2014 Cory Beams
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var LE = {};
LE.Lights = {
    POINT_LIGHT: "PointLight",
    DIRECTIONAL_LIGHT: "DirectionalLight",
    RADIAL_POINT_LIGHT: "RadialPointLight"
}, LE.LightShaders = {
    POINT_LIGHT: 0,
    POINT_LIGHT2: 1,
    RADIAL_POINT_LIGHT: 2
};
LE.Polygon = function (t) {
    null == t && (t = {}), this.x = t.x || 0, this.y = t.y || 0, this._rotation = t.rotation || 0, this.vertices = t.vertices || LE.Vertices.regularPolygon(50, 3), this.centerPoint = LE.Utilities.centerOfVerts(this.vertices), this.colour = t.colour || new LE.Colour(255, 255, 255, 255)
}, LE.Polygon.prototype = {
    get rotation() {
        return this._rotation
    },
    set rotation(t) {
        var i = Math.abs(this._rotation - t);
        this._rotation = t;
        for (var e = LE.Utilities.degToRad(i), o = 0; o < this.vertices.length; o++) {
            var s = this.vertices[o].x,
                r = this.vertices[o].y,
                n = this.centerPoint.x,
                c = this.centerPoint.y,
                h = Math.cos(e) * (s - n) - Math.sin(e) * (r - c) + n,
                a = Math.sin(e) * (s - n) + Math.cos(e) * (r - c) + c;
            this.vertices[o].x = h, this.vertices[o].y = a
        }
    }
};
LE.Texture = function (t) {
    null == t && console.error("The Texture class requires the textureURL parameter."), this.x = t.x || 0, this.y = t.y || 0, this._rotation = t.rotation || 0, this.vertices = t.vertices || LE.Vertices.square(50, 50), this.centerPoint = LE.Utilities.centerOfVerts(this.vertices), this.textureURL = t.textureURL
}, LE.Texture.prototype = {
    get rotation() {
        return this._rotation
    },
    set rotation(t) {
        var e = Math.abs(this._rotation - t);
        this._rotation = t;
        for (var i = LE.Utilities.degToRad(e), r = 0; r < this.vertices.length; r++) {
            var s = this.vertices[r].x,
                o = this.vertices[r].y,
                h = this.centerPoint.x,
                c = this.centerPoint.y,
                n = Math.cos(i) * (s - h) - Math.sin(i) * (o - c) + h,
                a = Math.sin(i) * (s - h) + Math.cos(i) * (o - c) + c;
            this.vertices[r].x = n, this.vertices[r].y = a
        }
    }
};
LE.Colour = function (i, t, h, s) {
    this.r = i, this.g = t, this.b = h, this.a = s
};
LE.Vertices = {
    square: function (t) {
        var r = [{
            x: 0,
            y: 0
        }, {
            x: 0,
            y: t
        }, {
            x: t,
            y: t
        }, {
            x: t,
            y: 0
        }];
        return r
    },
    rectangle: function (t, r) {
        var e = [{
            x: 0,
            y: 0
        }, {
            x: 0,
            y: r
        }, {
            x: t,
            y: r
        }, {
            x: t,
            y: 0
        }];
        return e
    },
    rhombus: function (t, r) {
        var e = [{
            x: 0,
            y: 0
        }];
        return e.push({
            x: Math.sin(LE.Utilities.degToRad(r)) * t,
            y: Math.cos(LE.Utilities.degToRad(r)) * t
        }), e.push({
            x: e[1].x + t,
            y: e[1].y
        }), e.push({
            x: e[0].x + t,
            y: e[0].y
        }), e
    },
    parallelogram: function (t, r, e) {
        var i = [{
            x: 0,
            y: 0
        }];
        return i.push({
            x: Math.sin(LE.Utilities.degToRad(e)) * t,
            y: Math.cos(LE.Utilities.degToRad(e)) * r
        }), i.push({
            x: i[1].x + t,
            y: i[1].y
        }), i.push({
            x: i[0].x + t,
            y: i[0].y
        }), i
    },
    trapezium: function (t, r, e, i) {
        var n = [{
            x: 0,
            y: 0
        }];
        return n.push({
            x: i,
            y: e
        }), n.push({
            x: n[1].x + r,
            y: n[1].y
        }), n.push({
            x: n[0].x + t,
            y: n[0].y
        }), n
    },
    trapezoid: function () {},
    kite: function () {},
    regularPolygon: function (t, r) {
        3 > r && console.error("A regular polygon cannot have less than 3 vertices.");
        for (var e = [], i = 0; r > i; i++) e.push({
            x: Math.sin(i / r * 2 * Math.PI) * t / 2,
            y: Math.cos(i / r * 2 * Math.PI) * t / 2
        });
        for (var n = LE.Utilities.sizeFromVerts(e), i = 0; i < e.length; i++) e[i].x += n.width / 2, e[i].y += n.height / 2;
        return e
    }
};
LE.ColourSpectrum = function () {
    this.colours = [];
    for (var o = 255, r = o, s = 0, u = 0, s = 0; o >= s; s++) this.colours.push(new LE.Colour(r, s, u, 255));
    for (var r = o; r >= 0; r--) this.colours.push(new LE.Colour(r, s, u, 255));
    for (var u = 0; o >= u; u++, s--) this.colours.push(new LE.Colour(r, s, u, 255));
    for (var t = 0; o >= t; t++, u--, r++) this.colours.push(new LE.Colour(r, s, u, 255));
    this.random = function () {
        return this.colours[Math.floor(Math.random() * this.colours.length)]
    }, this.get = function (o) {
        return o > this.colours.length || 0 > o ? void console.error("Index exceeds colour range") : this.colours[o]
    }
};
LE.Utilities = {
    toMatrix: function (t, i, r) {
        return 1 == r ? i / t.viewportWidth * t.viewportRatio * 2 : i / t.viewportHeight * 2
    },
    vertToMatrix: function (t, i, r) {
        return verts = {
            x: i / t.viewportWidth * t.viewportRatio * 2,
            y: r / t.viewportHeight * 2
        }
    },
    checkScreenBounds: function (t, i, r, e, n, o, h, a) {
        return h >= t - n && t + r + n >= h && a >= i - o && i + e + o >= a ? !0 : !1
    },
    degToRad: function (t) {
        return t * Math.PI / 180
    },
    minMaxFromVerts: function (t) {
        for (var i = 0, r = 0, e = 0, n = 0, o = 0; o < t.length; o++) 0 == o ? (i = t[o].x, r = t[o].x, e = t[o].y, n = t[o].y) : (i = t[o].x < i ? t[o].x : i, r = t[o].x > r ? t[o].x : r, e = t[o].y < e ? t[o].y : e, n = t[o].y > n ? t[o].y : n);
        return {
            minWidth: i,
            maxWidth: r,
            minHeight: e,
            maxHeight: n
        }
    },
    sizeFromVerts: function (t) {
        var i = this.minMaxFromVerts(t);
        return {
            width: Math.abs(i.maxWidth - i.minWidth),
            height: Math.abs(i.maxHeight - i.minHeight)
        }
    },
    centerOfVerts: function (t) {
        for (var i = 0, r = 0, e = 0; e < t.length; e++) i += t[e].x, r += t[e].y;
        return i /= t.length, r /= t.length, {
            x: i,
            y: r
        }
    },
    checkPointCollision: function (t, i, r) {
        function e(t, i, r, e, n) {
            for (var o, h, a = 0, o = 0, h = t - 1; t > o; h = o++) r[o] > n != r[h] > n && e < (i[h] - i[o]) * (n - r[o]) / (r[h] - r[o]) + i[o] && (a = !a);
            return a
        }
        for (var n = r.vertices.length, o = [], h = [], a = 0; n > a; a++) o.push(r.x + r.vertices[a].x), h.push(r.y + r.vertices[a].y);
        var u = e(n, o, h, t, i);
        return 1 == u ? !0 : !1
    }
};
LE.Vector2 = {
    sub: function (n, r) {
        var t = {
            x: n.x - r.x,
            y: n.y - r.y
        };
        return t
    },
    add: function (n, r) {
        var t = {
            x: n.x + r.x,
            y: n.y + r.y
        };
        return t
    },
    dot: function (n, r) {
        return n.x * r.x + n.y * r.y
    },
    equal: function (n, r) {
        return n.x == r.x && n.y == r.y ? !0 : !1
    },
    scale: function (n, r) {
        var t = {
            x: r.x * n,
            y: r.y * n
        };
        return t
    }
};
LE.AmbientLight = function (i) {
    this.colour = i
};
LE.DirectionalLight = function (t) {
    null == t && (t = {}), this.type = LE.Lights.DIRECTIONAL_LIGHT, this.x = t.x || 0, this.y = t.y || 0, this.rotation = t.rotation || 0, this.range = t.range || 90, this.colour = t.colour || new LE.Colour(255, 255, 255, 255), this.intensity = t.intensity || .1, this.shader = t.shader || LE.LightShaders.POINT_LIGHT, (this.intensity > 1 || this.intensity < 0) && console.error("Light intensity cannot be higher than 1.0 or less than 0.0.")
};
LE.PointLight = function (t) {
    null == t && (t = {}), this.type = LE.Lights.POINT_LIGHT, this.x = t.x || 0, this.y = t.y || 0, this.colour = t.colour || new LE.Colour(255, 255, 255, 255), this.intensity = t.intensity || .1, this.shader = t.shader || LE.LightShaders.POINT_LIGHT, (this.intensity > 1 || this.intensity < 0) && console.error("Light intensity cannot be higher than 1.0 or less than 0.0.")
};
LE.RadialPointLight = function (i) {
    null == i && (i = {}), this.type = LE.Lights.RADIAL_POINT_LIGHT, this.x = i.x || 0, this.y = i.y || 0, this.radius = i.radius || 200, this.colour = i.colour || new LE.Colour(255, 255, 255, 255), this.intensity = i.intensity || .1, this.shader = i.shader || LE.LightShaders.RADIAL_POINT_LIGHT, (this.intensity > 1 || this.intensity < 0) && console.error("Light intensity cannot be higher than 1.0 or less than 0.0.")
};
LE.Shader = function (e, t) {
    this.name = e, this.program = t
}, LE.Shaders = function () {
    this.selected, this.list = []
}, LE.Shaders.prototype.setCurrentShader = function (e, t) {
    e.useProgram(t), this.selected = t
}, LE.Shaders.prototype.getShaderFromHTML = function (e, t) {
    var r = document.getElementById(t);
    if (!r) return null;
    for (var a = "", o = r.firstChild; o;) 3 == o.nodeType && (a += o.textContent), o = o.nextSibling;
    var i;
    if ("x-shader/x-fragment" == r.type) i = e.createShader(this.gl.FRAGMENT_SHADER);
    else {
        if ("x-shader/x-vertex" != r.type) return null;
        i = e.createShader(this.gl.VERTEX_SHADER)
    }
    return e.shaderSource(i, a), e.compileShader(i), e.getShaderParameter(i, e.COMPILE_STATUS) ? i : (alert(e.getShaderInfoLog(i)), null)
}, LE.Shaders.prototype.getShaderFromVar = function (e, t, r) {
    var a;
    if ("Vert" == r || "Vertex" == r || "VertexShader" == r) a = e.createShader(e.VERTEX_SHADER);
    else {
        if ("Frag" != r && "Fragment" != r && "FragmentShader" != r) return void console.log("Error: Cannot get shader. Invalid type provided.");
        a = e.createShader(e.FRAGMENT_SHADER)
    }
    return e.shaderSource(a, t), e.compileShader(a), e.getShaderParameter(a, e.COMPILE_STATUS) ? a : (alert(e.getShaderInfoLog(a)), null)
}, LE.Shaders.prototype.createShader = function (e, t, r, a) {
    var o = e.createProgram();
    return e.attachShader(o, r), e.attachShader(o, a), e.linkProgram(o), e.getProgramParameter(o, e.LINK_STATUS) || alert("Could not initialise shader: " + o), e.useProgram(o), 1 == t ? this.enableTextureShaderAttribs(e, o) : this.enableRegularShaderAttribs(e, o), o.pMatrixUniform = e.getUniformLocation(o, "uPMatrix"), o.mvMatrixUniform = e.getUniformLocation(o, "uMVMatrix"), o
}, LE.Shaders.prototype.enableRegularShaderAttribs = function (e, t) {
    t.vertexPositionAttribute = e.getAttribLocation(t, "aVertexPosition"), e.enableVertexAttribArray(t.vertexPositionAttribute), t.vertexColorAttribute = e.getAttribLocation(t, "aVertexColor"), e.enableVertexAttribArray(t.vertexColorAttribute)
}, LE.Shaders.prototype.enableTextureShaderAttribs = function (e, t) {
    t.vertexPositionAttribute = e.getAttribLocation(t, "aVertexPosition"), e.enableVertexAttribArray(t.vertexPositionAttribute), t.textureCoordAttribute = e.getAttribLocation(t, "aTextureCoord"), e.enableVertexAttribArray(t.textureCoordAttribute)
};
LE.ShaderLib = {
    POINT_LIGHT_FRAG: "precision mediump float;uniform vec2 lightLocation;uniform vec3 lightColor;void main() {float distance = length(lightLocation - gl_FragCoord.xy);float attenuation = 1.0 / distance;vec4 color = vec4(attenuation, attenuation, attenuation, pow(attenuation, 3.0)) * vec4(lightColor, 1);gl_FragColor = color;}",
    POINT_LIGHT_FRAG2: "precision mediump float;uniform vec2 lightLocation;uniform vec3 lightColor;void main() {float distance = length(lightLocation - gl_FragCoord.xy);float attenuation = 1.0 / (1.0 + 0.1*distance + 0.01*distance*distance);vec4 color = vec4(attenuation, attenuation, attenuation, pow(attenuation, 3.0)) * vec4(lightColor, 1);gl_FragColor = color;}",
    MAIN_VERT: "attribute vec3 aVertexPosition;attribute vec4 aVertexColor;uniform mat4 uMVMatrix;uniform mat4 uPMatrix;varying vec4 vColor;void main(void) {gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);vColor = aVertexColor;}",
    RADIAL_LIGHT_FRAG: "precision mediump float;uniform vec2 lightLocation;uniform vec3 lightColor;uniform float radius;void main() {float distance  = length( lightLocation - gl_FragCoord.xy );float intensity = 1.0 - min( distance, radius ) / radius;gl_FragColor = vec4(intensity, intensity, intensity, 0.1) * vec4(lightColor.r / 10.0, lightColor.g / 10.0, lightColor.b / 10.0, 1);}",
    COLOUR_FRAG: "precision mediump float;uniform vec4 ambientLight;varying vec4 vColor;void main(void) {gl_FragColor = ambientLight * vColor;}",
    TEXTURE_FRAG: "precision mediump float;varying vec2 vTextureCoord;uniform vec4 ambientLight;uniform sampler2D uSampler;void main(void) {gl_FragColor = ambientLight * texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));}",
    TEXTURE_VERT: "attribute vec3 aVertexPosition;attribute vec2 aTextureCoord;uniform mat4 uMVMatrix;uniform mat4 uPMatrix;varying vec2 vTextureCoord;void main(void) {gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);vTextureCoord = aTextureCoord;}"
};
LE.OrthographicCamera = function (t, a) {
    this.x = t, this.y = a, this.mvMatrix = mat4.create(), this.pMatrix = mat4.create(), this.mvMatrixStack = []
}, LE.OrthographicCamera.prototype.ortho = function (t, a, r, i, o, h) {
    mat4.ortho(this.pMatrix, t, a, r, i, o, h)
}, LE.OrthographicCamera.prototype.identity = function (t) {
    mat4.identity(t)
}, LE.OrthographicCamera.prototype.translate = function (t, a, r) {
    mat4.translate(this.mvMatrix, this.mvMatrix, [t, a, r])
}, LE.OrthographicCamera.prototype.rotate = function (t, a, r, i) {
    mat4.rotate(this.mvMatrix, this.mvMatrix, t, [a, r, i])
}, LE.OrthographicCamera.prototype.mvPushMatrix = function () {
    var t = mat4.create();
    mat4.copy(t, this.mvMatrix), this.mvMatrixStack.push(t)
}, LE.OrthographicCamera.prototype.mvPopMatrix = function () {
    if (0 == this.mvMatrixStack.length) throw "Invalid popMatrix!";
    this.mvMatrix = this.mvMatrixStack.pop()
};
LE.WebGLRenderer = function (t) {
    null == t && console.error("To create a WebGLRenderer a canvas needs to be provided."), this.gl, this.canvas = t.canvas, this._scene = t.scene || new LE.Scene, this._camera = t.camera || new LE.OrthographicCamera(0, 0), this.shaders = new LE.Shaders, this.initGL(), this.initShaders(), this.prepareGL()
}, LE.WebGLRenderer.prototype = {
    get scene() {
        return this._scene
    },
    set scene(t) {
        t instanceof LE.Scene ? (this._scene = t, null != this.gl && this._scene.init(this.gl)) : console.warn("Object is not of type LE.Scene!")
    },
    get camera() {
        return this._camera
    },
    set camera(t) {
        t instanceof LE.OrthographicCamera ? (this._camera = t, null != this.gl && (this._camera.ortho(-this.gl.viewportRatio, this.gl.viewportRatio, -1, 1, .1, 100), this._camera.translate(-this.gl.viewportRatio, -1, -1))) : console.warn("Object is not of type LE.OrthographicCamera!")
    }
}, LE.WebGLRenderer.prototype.initGL = function () {
    try {
        this.gl = this.canvas.getContext("experimental-webgl", {
            stencil: !0
        }), this.gl.viewportWidth = canvas.width, this.gl.viewportHeight = canvas.height, this.gl.viewportRatio = canvas.width / canvas.height, null != this.scene && this.scene.init(this.gl)
    } catch (t) {}
    this.gl || alert("Could not initialise WebGL, sorry :-( ")
}, LE.WebGLRenderer.prototype.initShaders = function () {
    var t = this.shaders.getShaderFromVar(this.gl, LE.ShaderLib.POINT_LIGHT_FRAG, "Frag"),
        e = this.shaders.getShaderFromVar(this.gl, LE.ShaderLib.POINT_LIGHT_FRAG2, "Frag"),
        s = this.shaders.getShaderFromVar(this.gl, LE.ShaderLib.MAIN_VERT, "Vert"),
        i = this.shaders.getShaderFromVar(this.gl, LE.ShaderLib.RADIAL_LIGHT_FRAG, "Frag"),
        h = this.shaders.getShaderFromVar(this.gl, LE.ShaderLib.COLOUR_FRAG, "Frag"),
        r = this.shaders.getShaderFromVar(this.gl, LE.ShaderLib.TEXTURE_FRAG, "Frag"),
        a = this.shaders.getShaderFromVar(this.gl, LE.ShaderLib.TEXTURE_VERT, "Vert");
    this.shaders.list.push(new LE.Shader("PrimaryPointLightShader", this.shaders.createShader(this.gl, !1, s, t))), this.shaders.list.push(new LE.Shader("SecondaryPointLightShader", this.shaders.createShader(this.gl, !1, s, e))), this.shaders.list.push(new LE.Shader("RadialPointLightShader", this.shaders.createShader(this.gl, !1, s, i))), this.shaders.list.push(new LE.Shader("PolygonShader", this.shaders.createShader(this.gl, !1, s, h))), this.shaders.list.push(new LE.Shader("TextureShader", this.shaders.createShader(this.gl, !0, a, r))), this.shaders.setCurrentShader(this.gl, this.shaders.list[0].program)
}, LE.WebGLRenderer.prototype.prepareGL = function () {
    this.gl.clearColor(0, 0, 0, 1), this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight), this.camera.ortho(-this.gl.viewportRatio, this.gl.viewportRatio, -1, 1, .1, 100), this.camera.identity(this.camera.mvMatrix), this.camera.translate(-this.gl.viewportRatio, -1, -1), this.gl.enable(this.gl.DEPTH_TEST), this.gl.frontFace(this.gl.CW), this.gl.enable(this.gl.STENCIL_TEST)
}, LE.WebGLRenderer.prototype.setMatrixUniforms = function (t) {
    this.gl.uniformMatrix4fv(t.pMatrixUniform, !1, this.camera.pMatrix), this.gl.uniformMatrix4fv(t.mvMatrixUniform, !1, this.camera.mvMatrix)
}, LE.WebGLRenderer.prototype.setClearColour = function (t, e, s, i) {
    this.gl.clearColor(t / 255, e / 255, s / 255, i / 255)
}, LE.WebGLRenderer.prototype.clear = function () {
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT)
}, LE.WebGLRenderer.prototype.translate = function (t, e, s) {
    this.camera.translate(LE.Utilities.toMatrix(this.gl, t, !0), LE.Utilities.toMatrix(this.gl, e, !1), 0)
}, LE.WebGLRenderer.prototype.resize = function (t, e) {
    (t != canvas.width || e != canvas.height) && (canvas.width = t, canvas.height = e, this.camera.translate(+this.gl.viewportRatio, 1, 1), this.gl.viewportWidth = t, this.gl.viewportHeight = e, this.gl.viewportRatio = t / e, this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight), this.camera.ortho(-this.gl.viewportRatio, this.gl.viewportRatio, -1, 1, .1, 100), this.camera.translate(-this.gl.viewportRatio, -1, -1), this.scene.initBuffers())
}, LE.WebGLRenderer.prototype.render = function () {
    this.renderObjects(), this.renderShadowObjects(), this.renderLightsAndShadows()
}, LE.WebGLRenderer.prototype.renderObjects = function () {
    this.translate(-this.camera.x, -this.camera.y), this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    for (var t = 0; t < this.scene.objects.length; t++) {
        var e = LE.Utilities.sizeFromVerts(this.scene.objects[t].vertices);
        LE.Utilities.checkScreenBounds(this.camera.x, this.camera.y, this.gl.viewportWidth, this.gl.viewportHeight, e.width, e.height, this.scene.objects[t].x, this.scene.objects[t].y) && (this.scene.objects[t] instanceof LE.Texture ? this.renderTextureObject(this.scene.objects, t) : this.renderObject(this.scene.objects, t))
    }
    this.translate(this.camera.x, this.camera.y)
}, LE.WebGLRenderer.prototype.renderShadowObjects = function () {
    this.translate(-this.camera.x, -this.camera.y), this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    for (var t = 0; t < this.scene.shadowObjects.length; t++) {
        var e = LE.Utilities.sizeFromVerts(this.scene.shadowObjects[t].vertices);
        LE.Utilities.checkScreenBounds(this.camera.x, this.camera.y, this.gl.viewportWidth, this.gl.viewportHeight, e.width, e.height, this.scene.shadowObjects[t].x, this.scene.shadowObjects[t].y) && (this.scene.shadowObjects[t] instanceof LE.Texture ? this.renderTextureObject(this.scene.shadowObjects, t) : this.renderObject(this.scene.shadowObjects, t))
    }
    this.translate(this.camera.x, this.camera.y)
}, LE.WebGLRenderer.prototype.renderLightsAndShadows = function () {
    this.translate(-this.camera.x, -this.camera.y), this.gl.bindTexture(this.gl.TEXTURE_2D, null), 1 == this.pointLightShaderSelected ? this.shaders.setCurrentShader(this.gl, this.shaders.list[0].program) : this.shaders.setCurrentShader(this.gl, this.shaders.list[1].program), this.gl.enable(this.gl.STENCIL_TEST), this.gl.depthMask(!1);
    for (var t = 0; t < this.scene.lights.length; t++) {
        var e = [];
        this.gl.stencilOp(this.gl.KEEP, this.gl.KEEP, this.gl.REPLACE), this.gl.stencilFunc(this.gl.ALWAYS, 1, 1), this.gl.colorMask(!1, !1, !1, !1);
        var s = 0;
        if (null != this.scene.lights[t].polygonIndex && (s = this.scene.lights[t].polygonIndex), LE.Utilities.checkScreenBounds(this.camera.x, this.camera.y, this.gl.viewportWidth, this.gl.viewportHeight, 500, 500, this.scene.lights[t].x, this.scene.lights[t].y)) {
            for (var i = s; i < this.scene.shadowObjects.length && !(i > s && null != this.scene.lights[t].polygonIndex); i++) {
                var h, r, a, n, l;
                if (this.scene.lights[t].type === LE.Lights.RADIAL_POINT_LIGHT) {
                    var o = LE.Utilities.sizeFromVerts(this.scene.shadowObjects[i].vertices);
                    h = this.scene.lights[t].radius + o.width + o.height, r = 1, a = this.scene.lights[t].x - (this.scene.shadowObjects[i].x + o.width / 2), a *= a, n = this.scene.lights[t].y - (this.scene.shadowObjects[i].y + o.height / 2), n *= n, l = Math.sqrt(a + n)
                } else h = 1, r = 1, l = 1;
                if (h + r > l) {
                    for (var c = [], g = 0; g < this.scene.shadowObjects[i].vertices.length; g++) c.push({
                        x: this.scene.shadowObjects[i].vertices[g].x + this.scene.shadowObjects[i].x,
                        y: this.scene.shadowObjects[i].vertices[g].y + this.scene.shadowObjects[i].y
                    });
                    for (var d = 0; d < c.length; d++) {
                        var u = c[d],
                            f = c[(d + 1) % c.length],
                            b = LE.Vector2.sub(f, u),
                            L = {
                                x: b.y,
                                y: -b.x
                            },
                            m = {
                                x: this.scene.lights[t].x,
                                y: this.scene.lights[t].y
                            },
                            E = LE.Vector2.sub(u, m);
                        if (LE.Vector2.dot(L, E) > 0) {
                            var x = LE.Vector2.add(u, LE.Vector2.scale(500, LE.Vector2.sub(u, m))),
                                v = LE.Vector2.add(f, LE.Vector2.scale(500, LE.Vector2.sub(f, m)));
                            e.push(x.x / this.gl.viewportWidth * this.gl.viewportRatio * 2, x.y / this.gl.viewportHeight * 2, 0, u.x / this.gl.viewportWidth * this.gl.viewportRatio * 2, u.y / this.gl.viewportHeight * 2, 0, v.x / this.gl.viewportWidth * this.gl.viewportRatio * 2, v.y / this.gl.viewportHeight * 2, 0, u.x / this.gl.viewportWidth * this.gl.viewportRatio * 2, u.y / this.gl.viewportHeight * 2, 0, v.x / this.gl.viewportWidth * this.gl.viewportRatio * 2, v.y / this.gl.viewportHeight * 2, 0, f.x / this.gl.viewportWidth * this.gl.viewportRatio * 2, f.y / this.gl.viewportHeight * 2, 0)
                        }
                    }
                }
            }
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.scene.shadowBuffers[0]), this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(e), this.gl.DYNAMIC_DRAW), this.scene.shadowBuffers[0].itemSize = 3, this.scene.shadowBuffers[0].numItems = e.length / 3, this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.scene.shadowBuffers[0]), this.gl.vertexAttribPointer(this.shaders.selected.vertexPositionAttribute, this.scene.shadowBuffers[0].itemSize, this.gl.FLOAT, !1, 0, 0), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.scene.shadowColourBuffers[0]), this.gl.vertexAttribPointer(this.shaders.selected.vertexColorAttribute, this.scene.shadowColourBuffers[0].itemSize, this.gl.FLOAT, !1, 0, 0), this.setMatrixUniforms(this.shaders.selected), this.gl.drawArrays(this.gl.TRIANGLES, 0, this.scene.shadowBuffers[0].numItems)
        }
        if (this.gl.colorMask(!0, !0, !0, !0), LE.Utilities.checkScreenBounds(this.camera.x, this.camera.y, this.gl.viewportWidth, this.gl.viewportHeight, 500, 500, this.scene.lights[t].x, this.scene.lights[t].y)) {
            this.gl.stencilOp(this.gl.KEEP, this.gl.KEEP, this.gl.KEEP), this.gl.stencilFunc(this.gl.EQUAL, 0, 1), this.shaders.setCurrentShader(this.gl, this.shaders.list[this.scene.lights[t].shader].program), this.gl.enable(this.gl.BLEND), this.gl.blendFunc(this.gl.ONE, this.gl.ONE), this.gl.uniform2f(this.gl.getUniformLocation(this.shaders.selected, "lightLocation"), this.scene.lights[t].x - this.camera.x, this.scene.lights[t].y - this.camera.y), this.gl.uniform3f(this.gl.getUniformLocation(this.shaders.selected, "lightColor"), this.scene.lights[t].colour.r * this.scene.lights[t].intensity, this.scene.lights[t].colour.g * this.scene.lights[t].intensity, this.scene.lights[t].colour.b * this.scene.lights[t].intensity), null != this.scene.lights[t].radius && this.gl.uniform1f(this.gl.getUniformLocation(this.shaders.selected, "radius"), this.scene.lights[t].radius), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.scene.lightBuffers[this.scene.lights[t].bufferIndex]), this.gl.vertexAttribPointer(this.shaders.selected.vertexColorAttribute, 3, this.gl.FLOAT, !1, 0, 0), this.gl.vertexAttribPointer(this.shaders.selected.vertexPositionAttribute, this.scene.lightBuffers[this.scene.lights[t].bufferIndex].itemSize, this.gl.FLOAT, !1, 0, 0);
            var p = LE.Utilities.vertToMatrix(this.gl, this.scene.lights[t].x, this.scene.lights[t].y);
            this.camera.translate(p.x, p.y, 0), this.camera.mvPushMatrix(), null != this.scene.lights[t].rotation && this.camera.rotate(LE.Utilities.degToRad(this.scene.lights[t].rotation), 0, 0, 1), this.setMatrixUniforms(this.shaders.selected), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, this.scene.lightBuffers[this.scene.lights[t].bufferIndex].numItems), this.camera.mvPopMatrix(), this.camera.translate(-p.x, -p.y, 0), this.gl.disable(this.gl.BLEND), this.gl.clear(this.gl.STENCIL_BUFFER_BIT)
        }
    }
    this.translate(this.camera.x, this.camera.y)
}, LE.WebGLRenderer.prototype.renderTextureObject = function (t, e) {
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.scene.objectBuffers[t[e].bufferIndex]), this.gl.vertexAttribPointer(this.shaders.selected.vertexPositionAttribute, this.scene.objectBuffers[t[e].bufferIndex].itemSize, this.gl.FLOAT, !1, 0, 0), this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA), this.gl.enable(this.gl.BLEND), this.shaders.setCurrentShader(this.gl, this.shaders.list[4].program), this.gl.uniform4f(this.gl.getUniformLocation(this.shaders.selected, "ambientLight"), this.scene.ambientLight.colour.r / 255, this.scene.ambientLight.colour.g / 255, this.scene.ambientLight.colour.b / 255, this.scene.ambientLight.colour.a / 255), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.scene.objectTextureBuffers[t[e].bufferIndex]), this.gl.vertexAttribPointer(this.shaders.selected.textureCoordAttribute, this.scene.objectTextureBuffers[t[e].bufferIndex].itemSize, this.gl.FLOAT, !1, 0, 0), this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, this.scene.textures[t[e].textureIndex]), this.gl.uniform1i(this.shaders.selected.samplerUniform, 0);
    var s = LE.Utilities.vertToMatrix(this.gl, t[e].x, t[e].y),
        i = LE.Utilities.vertToMatrix(this.gl, t[e].centerPoint.x, t[e].centerPoint.y);
    this.camera.translate(s.x, s.y, 0), this.camera.mvPushMatrix(), this.camera.translate(i.x, i.y, 0), this.camera.rotate(LE.Utilities.degToRad(t[e].rotation), 0, 0, 1), this.camera.translate(-i.x, -i.y, 0), this.setMatrixUniforms(this.shaders.selected), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, this.scene.objectBuffers[t[e].bufferIndex].numItems), this.camera.mvPopMatrix(), this.camera.translate(-s.x, -s.y, 0), this.gl.disable(this.gl.BLEND)
}, LE.WebGLRenderer.prototype.renderObject = function (t, e) {
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.scene.objectBuffers[t[e].bufferIndex]), this.gl.vertexAttribPointer(this.shaders.selected.vertexPositionAttribute, this.scene.objectBuffers[t[e].bufferIndex].itemSize, this.gl.FLOAT, !1, 0, 0), this.shaders.setCurrentShader(this.gl, this.shaders.list[3].program), this.gl.uniform4f(this.gl.getUniformLocation(this.shaders.selected, "ambientLight"), this.scene.ambientLight.colour.r / 250, this.scene.ambientLight.colour.g / 255, this.scene.ambientLight.colour.b / 255, this.scene.ambientLight.colour.a / 255), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.scene.objectColourBuffers[t[e].bufferIndex]), this.gl.vertexAttribPointer(this.shaders.selected.vertexColorAttribute, this.scene.objectColourBuffers[t[e].bufferIndex].itemSize, this.gl.FLOAT, !1, 0, 0);
    var s = LE.Utilities.vertToMatrix(this.gl, t[e].x, t[e].y),
        i = LE.Utilities.vertToMatrix(this.gl, t[e].centerPoint.x, t[e].centerPoint.y);
    this.camera.translate(s.x, s.y, 0), this.camera.mvPushMatrix(), this.camera.translate(i.x, i.y, 0), this.camera.rotate(LE.Utilities.degToRad(t[e].rotation), 0, 0, 1), this.camera.translate(-i.x, -i.y, 0), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.scene.objectIndexBuffers[t[e].bufferIndex]), this.setMatrixUniforms(this.shaders.selected), this.gl.drawElements(this.gl.TRIANGLES, this.scene.objectIndexBuffers[t[e].bufferIndex].numItems, this.gl.UNSIGNED_SHORT, 0), this.camera.mvPopMatrix(), this.camera.translate(-s.x, -s.y, 0), this.gl.disable(this.gl.BLEND)
};
LE.Scene = function (t) {
    null == t && (t = {}), this.gl, this.lights = [], this.shadowObjects = [], this.objects = [], this.ambientLight = t.ambientLight || new LE.AmbientLight(new LE.Colour(255, 255, 255, 255)), this.textures = [], this.objectBuffers = [], this.objectColourBuffers = [], this.objectIndexBuffers = [], this.objectTextureBuffers = [], this.lightBuffers = [], this.shadowBuffers = [], this.shadowColourBuffers = []
}, LE.Scene.prototype.init = function (t) {
    this.gl = t, this.initBuffers(), this.initTextures()
}, LE.Scene.prototype.initBuffers = function (t) {
    for (var e = 0; e < this.shadowObjects.length; e++) this.shadowObjects[e] instanceof LE.Texture ? this.initTextureBuffer(this.shadowObjects, e) : this.initPolygonBuffer(this.shadowObjects, e);
    for (var i = 0; i < this.objects.length; i++) this.shadowObjects[i] instanceof LE.Texture ? this.initTextureBuffer(this.objects, i) : this.initPolygonBuffer(this.objects, i);
    this.shadowColourBuffers[0] = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.shadowColourBuffers[0]), colors = [];
    for (var s = 0; 1e4 > s; s++) colors = colors.concat([1, 1, 1, .5]);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW), this.shadowColourBuffers[0].itemSize = 4, this.shadowColourBuffers[0].numItems = 1e4, this.shadowBuffers[0] = this.gl.createBuffer();
    for (var r = 0; r < this.lights.length; r++) this.initLightBuffer(this.lights, r)
}, LE.Scene.prototype.initTextureBuffer = function (t, e) {
    for (var i = LE.Utilities.sizeFromVerts(t[e].vertices), s = e; s >= 0; s--) {
        var r = LE.Utilities.sizeFromVerts(t[s].vertices);
        if (t[e] != t[s] && t[e].vertices.length == t[s].vertices.length && i.width == r.width && i.height == r.height) t[e].bufferIndex = t[s].bufferIndex;
        else if (0 == s) {
            t[e].bufferIndex = this.objectBuffers.length, this.objectBuffers[this.objectBuffers.length] = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.objectBuffers[t[e].bufferIndex]);
            var h = [];
            h = [LE.Utilities.toMatrix(this.gl, i.width, !0), LE.Utilities.toMatrix(this.gl, i.height, !1), 0, 0, LE.Utilities.toMatrix(this.gl, i.height, !1), 0, LE.Utilities.toMatrix(this.gl, i.width, !0), 0, 0, 0, 0, 0], this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(h), this.gl.STATIC_DRAW), this.objectBuffers[t[e].bufferIndex].itemSize = 3, this.objectBuffers[t[e].bufferIndex].numItems = h.length / 3, this.objectIndexBuffers[this.objectIndexBuffers.length] = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.objectIndexBuffers[t[e].bufferIndex]);
            var f = earcut(h, null, 3);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(f), this.gl.STATIC_DRAW), this.objectIndexBuffers[t[e].bufferIndex].itemSize = 1, this.objectIndexBuffers[t[e].bufferIndex].numItems = f.length, this.objectTextureBuffers[t[e].bufferIndex] = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.objectTextureBuffers[t[e].bufferIndex]);
            var o = [1, 1, 0, 1, 1, 0, 0, 0];
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(o), this.gl.STATIC_DRAW), this.objectTextureBuffers[t[e].bufferIndex].itemSize = 2, this.objectTextureBuffers[t[e].bufferIndex].numItems = 4
        }
    }
}, LE.Scene.prototype.comparePolygons = function (t, e) {
    if (t != e) {
        if (t.vertices.length != e.vertices.length) return !1;
        for (var i = 0; i < t.vertices.length; i++)
            if (t.vertices[i].x != e.vertices[i].x || t.vertices[i].y != e.vertices[i].y) return !1;
        if (null == e.colour) return !0;
        if (t.colour.r == e.colour.r && t.colour.g == e.colour.g && t.colour.b == e.colour.b && t.colour.a == e.colour.a) return !0
    }
    return !1
}, LE.Scene.prototype.initPolygonBuffer = function (t, e) {
    for (var i = e; i >= 0; i--) {
        if (this.comparePolygons(t[e], t[i])) {
            t[e].bufferIndex = t[i].bufferIndex;
            break
        }
        if (0 == i) {
            t[e].bufferIndex = this.objectBuffers.length, this.objectBuffers[this.objectBuffers.length] = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.objectBuffers[t[e].bufferIndex]);
            for (var s = [], r = 0; r < t[e].vertices.length; r++) s.push(LE.Utilities.toMatrix(this.gl, t[e].vertices[r].x, !0), LE.Utilities.toMatrix(this.gl, t[e].vertices[r].y, !1), 0);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(s), this.gl.STATIC_DRAW), this.objectBuffers[t[e].bufferIndex].itemSize = 3, this.objectBuffers[t[e].bufferIndex].numItems = s.length / 3, this.objectIndexBuffers[this.objectIndexBuffers.length] = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.objectIndexBuffers[t[e].bufferIndex]);
            var h = earcut(s, null, 3);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(h), this.gl.STATIC_DRAW), this.objectIndexBuffers[t[e].bufferIndex].itemSize = 1, this.objectIndexBuffers[t[e].bufferIndex].numItems = h.length, this.objectColourBuffers[t[e].bufferIndex] = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.objectColourBuffers[t[e].bufferIndex]), colors = [];
            for (var f = 0; f < t[e].vertices.length; f++) colors = colors.concat([t[e].colour.r / 255, t[e].colour.g / 255, t[e].colour.b / 255, t[e].colour.a / 255]);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW), this.objectColourBuffers[t[e].bufferIndex].itemSize = 4, this.objectColourBuffers[t[e].bufferIndex].numItems = t[e].vertices.length / 3
        }
    }
}, LE.Scene.prototype.initTextures = function () {
    for (var t = 0; t < this.shadowObjects.length; t++) this.shadowObjects[t] instanceof LE.Texture && this.assignTextureIndices(this.shadowObjects, t);
    for (var e = 0; e < this.objects.length; e++) this.shadowObjects[e] instanceof LE.Texture && this.assignTextureIndices(this.objects, e)
}, LE.Scene.prototype.assignTextureIndices = function (t, e) {
    for (var i = this, s = !0, r = 0; r < this.textures.length; r++) {
        var h = this.gl.createTexture();
        if (h.image = new Image, h.image.src = t[e].textureURL, h.image.src == this.textures[r].image.src) {
            t[e].textureIndex = r, s = !1;
            break
        }
    }
    if (1 == s) {
        var f = this.gl.createTexture();
        this.textures.push(f), this.textures[this.textures.length - 1].image = new Image, this.textures[this.textures.length - 1].image.onload = function () {
            for (var t = 0; t < i.textures.length; t++)
                if (0 == i.textures[t].hasLoaded) {
                    i.handleLoadedTexture(i.textures[t]);
                    break
                }
        }, this.textures[this.textures.length - 1].image.src = t[e].textureURL, this.textures[this.textures.length - 1].hasLoaded = !1, t[e].textureIndex = this.textures.length - 1
    }
}, LE.Scene.prototype.handleLoadedTexture = function (t) {
    this.gl.bindTexture(this.gl.TEXTURE_2D, t), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !0), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, t.image), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.generateMipmap(this.gl.TEXTURE_2D), this.gl.bindTexture(this.gl.TEXTURE_2D, null), t.hasLoaded = !0
}, LE.Scene.prototype.initLightBuffer = function (t, e) {
    for (var i = e; i >= 0; i--) {
        if (t[e] != t[i] && t[e].type === t[i].type) {
            t[e].bufferIndex = t[i].bufferIndex;
            break
        }
        if (0 == i)
            if (t[e].bufferIndex = this.lightBuffers.length, this.lightBuffers[this.lightBuffers.length] = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.lightBuffers[t[e].bufferIndex]), t[e].type === LE.Lights.POINT_LIGHT || t[e].type === LE.Lights.RADIAL_POINT_LIGHT) vertices = [LE.Utilities.toMatrix(this.gl, 5 * this.gl.viewportWidth, !0), LE.Utilities.toMatrix(this.gl, 5 * this.gl.viewportHeight, !1), 0, LE.Utilities.toMatrix(this.gl, 5 * -this.gl.viewportWidth, !0), LE.Utilities.toMatrix(this.gl, 5 * this.gl.viewportHeight, !1), 0, LE.Utilities.toMatrix(this.gl, 5 * this.gl.viewportWidth, !0), LE.Utilities.toMatrix(this.gl, 5 * -this.gl.viewportHeight, !1), 0, LE.Utilities.toMatrix(this.gl, 5 * -this.gl.viewportWidth, !0), LE.Utilities.toMatrix(this.gl, 5 * -this.gl.viewportHeight, !1), 0], this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.DYNAMIC_DRAW), this.lightBuffers[t[e].bufferIndex].itemSize = 3, this.lightBuffers[t[e].bufferIndex].numItems = 4;
            else if (t[e].type === LE.Lights.DIRECTIONAL_LIGHT) {
            var s = t[e].range,
                r = LE.Utilities.degToRad(s / 2),
                h = 2e5,
                f = Math.round(0 + h * Math.cos(r)),
                o = Math.round(0 + h * Math.sin(r));
            r = LE.Utilities.degToRad(-s / 2);
            var n = Math.round(0 + h * Math.cos(r)),
                l = Math.round(0 + h * Math.sin(r));
            vertices = [0, 0, 0, LE.Utilities.toMatrix(this.gl, f, !0), LE.Utilities.toMatrix(this.gl, o, !1), 0, LE.Utilities.toMatrix(this.gl, n, !0), LE.Utilities.toMatrix(this.gl, l, !1), 0], this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.DYNAMIC_DRAW), this.lightBuffers[t[e].bufferIndex].itemSize = 3, this.lightBuffers[t[e].bufferIndex].numItems = 3
        }
    }
}, LE.Scene.prototype.addLight = function (t) {
    (t instanceof LE.PointLight || t instanceof LE.DirectionalLight || t instanceof LE.RadialPointLight) && (this.lights.push(t), null != this.gl && this.initLightBuffer(this.lights, this.lights.length - 1))
}, LE.Scene.prototype.addShadowObject = function (t) {
    t instanceof LE.Texture ? (this.shadowObjects.push(t), null != this.gl && (this.initTextureBuffer(this.shadowObjects, this.shadowObjects.length - 1), this.assignTextureIndices(this.shadowObjects, this.shadowObjects.length - 1))) : t instanceof LE.Polygon && (this.shadowObjects.push(t), null != this.gl && this.initPolygonBuffer(this.shadowObjects, this.shadowObjects.length - 1))
}, LE.Scene.prototype.addObject = function (t) {
    t instanceof LE.Texture ? (this.objects.push(t), null != this.gl && (this.initTextureBuffer(this.objects, this.objects.length - 1), this.assignTextureIndices(this.objects, this.objects.length - 1))) : t instanceof LE.Polygon && (this.objects.push(t), null != this.gl && this.initPolygonBuffer(this.objects, this.objects.length - 1))
}, LE.Scene.prototype.removeLight = function (t) {
    (t instanceof LE.PointLight || t instanceof LE.DirectionalLight || t instanceof LE.RadialPointLight) && this.removeObjectAndBuffer(t, this.lights, [this.lightBuffers])
}, LE.Scene.prototype.removeShadowObject = function (t) {
    (t instanceof LE.Texture || t instanceof LE.Polygon) && this.removeObjectAndBuffer(t, this.shadowObjects, [this.objectBuffers, this.objectColourBuffers])
}, LE.Scene.prototype.removeObject = function (t) {
    (t instanceof LE.Texture || t instanceof LE.Polygon) && this.removeObjectAndBuffer(t, this.objects, [this.objectBuffers, this.objectColourBuffers])
}, LE.Scene.prototype.removeObjectAndBuffer = function (t, e, i) {
    for (var s = 0, r = 0; r < e.length; r++)
        if (t != e[r] && t.bufferIndex == e[r].bufferIndex) {
            s++;
            break
        }
    if (0 == s) {
        for (var r = 0; r < e.length; r++) e[r].bufferIndex > t.bufferIndex && e[r].bufferIndex--;
        for (var h = 0; h < i.length; h++) i[h].splice(t.bufferIndex, 1)
    }
    for (var r = 0; r < e.length; r++)
        if (e[r] == t) {
            e.splice(r, 1);
            break
        }
};
